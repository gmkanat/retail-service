// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

//go:generate minimock -i gitlab.ozon.dev/kanat_9999/homework/cart/internal/pkg/cart/service.CartRepository -o cart_repository_mock.go -n CartRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/kanat_9999/homework/cart/internal/pkg/cart/model"
)

// CartRepositoryMock implements mm_service.CartRepository
type CartRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddItem          func(ctx context.Context, userId int64, cartItem *model.CartItem) (err error)
	funcAddItemOrigin    string
	inspectFuncAddItem   func(ctx context.Context, userId int64, cartItem *model.CartItem)
	afterAddItemCounter  uint64
	beforeAddItemCounter uint64
	AddItemMock          mCartRepositoryMockAddItem

	funcClearCart          func(ctx context.Context, userId int64) (err error)
	funcClearCartOrigin    string
	inspectFuncClearCart   func(ctx context.Context, userId int64)
	afterClearCartCounter  uint64
	beforeClearCartCounter uint64
	ClearCartMock          mCartRepositoryMockClearCart

	funcGetCart          func(ctx context.Context, userId int64) (ca1 []model.CartItem, err error)
	funcGetCartOrigin    string
	inspectFuncGetCart   func(ctx context.Context, userId int64)
	afterGetCartCounter  uint64
	beforeGetCartCounter uint64
	GetCartMock          mCartRepositoryMockGetCart

	funcRemoveItem          func(ctx context.Context, userId int64, sku int64) (err error)
	funcRemoveItemOrigin    string
	inspectFuncRemoveItem   func(ctx context.Context, userId int64, sku int64)
	afterRemoveItemCounter  uint64
	beforeRemoveItemCounter uint64
	RemoveItemMock          mCartRepositoryMockRemoveItem
}

// NewCartRepositoryMock returns a mock for mm_service.CartRepository
func NewCartRepositoryMock(t minimock.Tester) *CartRepositoryMock {
	m := &CartRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddItemMock = mCartRepositoryMockAddItem{mock: m}
	m.AddItemMock.callArgs = []*CartRepositoryMockAddItemParams{}

	m.ClearCartMock = mCartRepositoryMockClearCart{mock: m}
	m.ClearCartMock.callArgs = []*CartRepositoryMockClearCartParams{}

	m.GetCartMock = mCartRepositoryMockGetCart{mock: m}
	m.GetCartMock.callArgs = []*CartRepositoryMockGetCartParams{}

	m.RemoveItemMock = mCartRepositoryMockRemoveItem{mock: m}
	m.RemoveItemMock.callArgs = []*CartRepositoryMockRemoveItemParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCartRepositoryMockAddItem struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockAddItemExpectation
	expectations       []*CartRepositoryMockAddItemExpectation

	callArgs []*CartRepositoryMockAddItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockAddItemExpectation specifies expectation struct of the CartRepository.AddItem
type CartRepositoryMockAddItemExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockAddItemParams
	paramPtrs          *CartRepositoryMockAddItemParamPtrs
	expectationOrigins CartRepositoryMockAddItemExpectationOrigins
	results            *CartRepositoryMockAddItemResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockAddItemParams contains parameters of the CartRepository.AddItem
type CartRepositoryMockAddItemParams struct {
	ctx      context.Context
	userId   int64
	cartItem *model.CartItem
}

// CartRepositoryMockAddItemParamPtrs contains pointers to parameters of the CartRepository.AddItem
type CartRepositoryMockAddItemParamPtrs struct {
	ctx      *context.Context
	userId   *int64
	cartItem **model.CartItem
}

// CartRepositoryMockAddItemResults contains results of the CartRepository.AddItem
type CartRepositoryMockAddItemResults struct {
	err error
}

// CartRepositoryMockAddItemOrigins contains origins of expectations of the CartRepository.AddItem
type CartRepositoryMockAddItemExpectationOrigins struct {
	origin         string
	originCtx      string
	originUserId   string
	originCartItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddItem *mCartRepositoryMockAddItem) Optional() *mCartRepositoryMockAddItem {
	mmAddItem.optional = true
	return mmAddItem
}

// Expect sets up expected params for CartRepository.AddItem
func (mmAddItem *mCartRepositoryMockAddItem) Expect(ctx context.Context, userId int64, cartItem *model.CartItem) *mCartRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartRepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.paramPtrs != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by ExpectParams functions")
	}

	mmAddItem.defaultExpectation.params = &CartRepositoryMockAddItemParams{ctx, userId, cartItem}
	mmAddItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddItem.expectations {
		if minimock.Equal(e.params, mmAddItem.defaultExpectation.params) {
			mmAddItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddItem.defaultExpectation.params)
		}
	}

	return mmAddItem
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.AddItem
func (mmAddItem *mCartRepositoryMockAddItem) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartRepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &CartRepositoryMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddItem
}

// ExpectUserIdParam2 sets up expected param userId for CartRepository.AddItem
func (mmAddItem *mCartRepositoryMockAddItem) ExpectUserIdParam2(userId int64) *mCartRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartRepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &CartRepositoryMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.userId = &userId
	mmAddItem.defaultExpectation.expectationOrigins.originUserId = minimock.CallerInfo(1)

	return mmAddItem
}

// ExpectCartItemParam3 sets up expected param cartItem for CartRepository.AddItem
func (mmAddItem *mCartRepositoryMockAddItem) ExpectCartItemParam3(cartItem *model.CartItem) *mCartRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartRepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &CartRepositoryMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.cartItem = &cartItem
	mmAddItem.defaultExpectation.expectationOrigins.originCartItem = minimock.CallerInfo(1)

	return mmAddItem
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.AddItem
func (mmAddItem *mCartRepositoryMockAddItem) Inspect(f func(ctx context.Context, userId int64, cartItem *model.CartItem)) *mCartRepositoryMockAddItem {
	if mmAddItem.mock.inspectFuncAddItem != nil {
		mmAddItem.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.AddItem")
	}

	mmAddItem.mock.inspectFuncAddItem = f

	return mmAddItem
}

// Return sets up results that will be returned by CartRepository.AddItem
func (mmAddItem *mCartRepositoryMockAddItem) Return(err error) *CartRepositoryMock {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartRepositoryMockAddItemExpectation{mock: mmAddItem.mock}
	}
	mmAddItem.defaultExpectation.results = &CartRepositoryMockAddItemResults{err}
	mmAddItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// Set uses given function f to mock the CartRepository.AddItem method
func (mmAddItem *mCartRepositoryMockAddItem) Set(f func(ctx context.Context, userId int64, cartItem *model.CartItem) (err error)) *CartRepositoryMock {
	if mmAddItem.defaultExpectation != nil {
		mmAddItem.mock.t.Fatalf("Default expectation is already set for the CartRepository.AddItem method")
	}

	if len(mmAddItem.expectations) > 0 {
		mmAddItem.mock.t.Fatalf("Some expectations are already set for the CartRepository.AddItem method")
	}

	mmAddItem.mock.funcAddItem = f
	mmAddItem.mock.funcAddItemOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// When sets expectation for the CartRepository.AddItem which will trigger the result defined by the following
// Then helper
func (mmAddItem *mCartRepositoryMockAddItem) When(ctx context.Context, userId int64, cartItem *model.CartItem) *CartRepositoryMockAddItemExpectation {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Set")
	}

	expectation := &CartRepositoryMockAddItemExpectation{
		mock:               mmAddItem.mock,
		params:             &CartRepositoryMockAddItemParams{ctx, userId, cartItem},
		expectationOrigins: CartRepositoryMockAddItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddItem.expectations = append(mmAddItem.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.AddItem return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockAddItemExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockAddItemResults{err}
	return e.mock
}

// Times sets number of times CartRepository.AddItem should be invoked
func (mmAddItem *mCartRepositoryMockAddItem) Times(n uint64) *mCartRepositoryMockAddItem {
	if n == 0 {
		mmAddItem.mock.t.Fatalf("Times of CartRepositoryMock.AddItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddItem.expectedInvocations, n)
	mmAddItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddItem
}

func (mmAddItem *mCartRepositoryMockAddItem) invocationsDone() bool {
	if len(mmAddItem.expectations) == 0 && mmAddItem.defaultExpectation == nil && mmAddItem.mock.funcAddItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddItem.mock.afterAddItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddItem implements mm_service.CartRepository
func (mmAddItem *CartRepositoryMock) AddItem(ctx context.Context, userId int64, cartItem *model.CartItem) (err error) {
	mm_atomic.AddUint64(&mmAddItem.beforeAddItemCounter, 1)
	defer mm_atomic.AddUint64(&mmAddItem.afterAddItemCounter, 1)

	mmAddItem.t.Helper()

	if mmAddItem.inspectFuncAddItem != nil {
		mmAddItem.inspectFuncAddItem(ctx, userId, cartItem)
	}

	mm_params := CartRepositoryMockAddItemParams{ctx, userId, cartItem}

	// Record call args
	mmAddItem.AddItemMock.mutex.Lock()
	mmAddItem.AddItemMock.callArgs = append(mmAddItem.AddItemMock.callArgs, &mm_params)
	mmAddItem.AddItemMock.mutex.Unlock()

	for _, e := range mmAddItem.AddItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddItem.AddItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddItem.AddItemMock.defaultExpectation.Counter, 1)
		mm_want := mmAddItem.AddItemMock.defaultExpectation.params
		mm_want_ptrs := mmAddItem.AddItemMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockAddItemParams{ctx, userId, cartItem}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddItem.t.Errorf("CartRepositoryMock.AddItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmAddItem.t.Errorf("CartRepositoryMock.AddItem got unexpected parameter userId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originUserId, *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

			if mm_want_ptrs.cartItem != nil && !minimock.Equal(*mm_want_ptrs.cartItem, mm_got.cartItem) {
				mmAddItem.t.Errorf("CartRepositoryMock.AddItem got unexpected parameter cartItem, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originCartItem, *mm_want_ptrs.cartItem, mm_got.cartItem, minimock.Diff(*mm_want_ptrs.cartItem, mm_got.cartItem))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddItem.t.Errorf("CartRepositoryMock.AddItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddItem.AddItemMock.defaultExpectation.results
		if mm_results == nil {
			mmAddItem.t.Fatal("No results are set for the CartRepositoryMock.AddItem")
		}
		return (*mm_results).err
	}
	if mmAddItem.funcAddItem != nil {
		return mmAddItem.funcAddItem(ctx, userId, cartItem)
	}
	mmAddItem.t.Fatalf("Unexpected call to CartRepositoryMock.AddItem. %v %v %v", ctx, userId, cartItem)
	return
}

// AddItemAfterCounter returns a count of finished CartRepositoryMock.AddItem invocations
func (mmAddItem *CartRepositoryMock) AddItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.afterAddItemCounter)
}

// AddItemBeforeCounter returns a count of CartRepositoryMock.AddItem invocations
func (mmAddItem *CartRepositoryMock) AddItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.beforeAddItemCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.AddItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddItem *mCartRepositoryMockAddItem) Calls() []*CartRepositoryMockAddItemParams {
	mmAddItem.mutex.RLock()

	argCopy := make([]*CartRepositoryMockAddItemParams, len(mmAddItem.callArgs))
	copy(argCopy, mmAddItem.callArgs)

	mmAddItem.mutex.RUnlock()

	return argCopy
}

// MinimockAddItemDone returns true if the count of the AddItem invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockAddItemDone() bool {
	if m.AddItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddItemMock.invocationsDone()
}

// MinimockAddItemInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockAddItemInspect() {
	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.AddItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddItemCounter := mm_atomic.LoadUint64(&m.afterAddItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemMock.defaultExpectation != nil && afterAddItemCounter < 1 {
		if m.AddItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.AddItem at\n%s", m.AddItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.AddItem at\n%s with params: %#v", m.AddItemMock.defaultExpectation.expectationOrigins.origin, *m.AddItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItem != nil && afterAddItemCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.AddItem at\n%s", m.funcAddItemOrigin)
	}

	if !m.AddItemMock.invocationsDone() && afterAddItemCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.AddItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddItemMock.expectedInvocations), m.AddItemMock.expectedInvocationsOrigin, afterAddItemCounter)
	}
}

type mCartRepositoryMockClearCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockClearCartExpectation
	expectations       []*CartRepositoryMockClearCartExpectation

	callArgs []*CartRepositoryMockClearCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockClearCartExpectation specifies expectation struct of the CartRepository.ClearCart
type CartRepositoryMockClearCartExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockClearCartParams
	paramPtrs          *CartRepositoryMockClearCartParamPtrs
	expectationOrigins CartRepositoryMockClearCartExpectationOrigins
	results            *CartRepositoryMockClearCartResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockClearCartParams contains parameters of the CartRepository.ClearCart
type CartRepositoryMockClearCartParams struct {
	ctx    context.Context
	userId int64
}

// CartRepositoryMockClearCartParamPtrs contains pointers to parameters of the CartRepository.ClearCart
type CartRepositoryMockClearCartParamPtrs struct {
	ctx    *context.Context
	userId *int64
}

// CartRepositoryMockClearCartResults contains results of the CartRepository.ClearCart
type CartRepositoryMockClearCartResults struct {
	err error
}

// CartRepositoryMockClearCartOrigins contains origins of expectations of the CartRepository.ClearCart
type CartRepositoryMockClearCartExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClearCart *mCartRepositoryMockClearCart) Optional() *mCartRepositoryMockClearCart {
	mmClearCart.optional = true
	return mmClearCart
}

// Expect sets up expected params for CartRepository.ClearCart
func (mmClearCart *mCartRepositoryMockClearCart) Expect(ctx context.Context, userId int64) *mCartRepositoryMockClearCart {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &CartRepositoryMockClearCartExpectation{}
	}

	if mmClearCart.defaultExpectation.paramPtrs != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by ExpectParams functions")
	}

	mmClearCart.defaultExpectation.params = &CartRepositoryMockClearCartParams{ctx, userId}
	mmClearCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmClearCart.expectations {
		if minimock.Equal(e.params, mmClearCart.defaultExpectation.params) {
			mmClearCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClearCart.defaultExpectation.params)
		}
	}

	return mmClearCart
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.ClearCart
func (mmClearCart *mCartRepositoryMockClearCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockClearCart {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &CartRepositoryMockClearCartExpectation{}
	}

	if mmClearCart.defaultExpectation.params != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Expect")
	}

	if mmClearCart.defaultExpectation.paramPtrs == nil {
		mmClearCart.defaultExpectation.paramPtrs = &CartRepositoryMockClearCartParamPtrs{}
	}
	mmClearCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmClearCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmClearCart
}

// ExpectUserIdParam2 sets up expected param userId for CartRepository.ClearCart
func (mmClearCart *mCartRepositoryMockClearCart) ExpectUserIdParam2(userId int64) *mCartRepositoryMockClearCart {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &CartRepositoryMockClearCartExpectation{}
	}

	if mmClearCart.defaultExpectation.params != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Expect")
	}

	if mmClearCart.defaultExpectation.paramPtrs == nil {
		mmClearCart.defaultExpectation.paramPtrs = &CartRepositoryMockClearCartParamPtrs{}
	}
	mmClearCart.defaultExpectation.paramPtrs.userId = &userId
	mmClearCart.defaultExpectation.expectationOrigins.originUserId = minimock.CallerInfo(1)

	return mmClearCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.ClearCart
func (mmClearCart *mCartRepositoryMockClearCart) Inspect(f func(ctx context.Context, userId int64)) *mCartRepositoryMockClearCart {
	if mmClearCart.mock.inspectFuncClearCart != nil {
		mmClearCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.ClearCart")
	}

	mmClearCart.mock.inspectFuncClearCart = f

	return mmClearCart
}

// Return sets up results that will be returned by CartRepository.ClearCart
func (mmClearCart *mCartRepositoryMockClearCart) Return(err error) *CartRepositoryMock {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &CartRepositoryMockClearCartExpectation{mock: mmClearCart.mock}
	}
	mmClearCart.defaultExpectation.results = &CartRepositoryMockClearCartResults{err}
	mmClearCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClearCart.mock
}

// Set uses given function f to mock the CartRepository.ClearCart method
func (mmClearCart *mCartRepositoryMockClearCart) Set(f func(ctx context.Context, userId int64) (err error)) *CartRepositoryMock {
	if mmClearCart.defaultExpectation != nil {
		mmClearCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.ClearCart method")
	}

	if len(mmClearCart.expectations) > 0 {
		mmClearCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.ClearCart method")
	}

	mmClearCart.mock.funcClearCart = f
	mmClearCart.mock.funcClearCartOrigin = minimock.CallerInfo(1)
	return mmClearCart.mock
}

// When sets expectation for the CartRepository.ClearCart which will trigger the result defined by the following
// Then helper
func (mmClearCart *mCartRepositoryMockClearCart) When(ctx context.Context, userId int64) *CartRepositoryMockClearCartExpectation {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockClearCartExpectation{
		mock:               mmClearCart.mock,
		params:             &CartRepositoryMockClearCartParams{ctx, userId},
		expectationOrigins: CartRepositoryMockClearCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmClearCart.expectations = append(mmClearCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.ClearCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockClearCartExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockClearCartResults{err}
	return e.mock
}

// Times sets number of times CartRepository.ClearCart should be invoked
func (mmClearCart *mCartRepositoryMockClearCart) Times(n uint64) *mCartRepositoryMockClearCart {
	if n == 0 {
		mmClearCart.mock.t.Fatalf("Times of CartRepositoryMock.ClearCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClearCart.expectedInvocations, n)
	mmClearCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClearCart
}

func (mmClearCart *mCartRepositoryMockClearCart) invocationsDone() bool {
	if len(mmClearCart.expectations) == 0 && mmClearCart.defaultExpectation == nil && mmClearCart.mock.funcClearCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClearCart.mock.afterClearCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClearCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ClearCart implements mm_service.CartRepository
func (mmClearCart *CartRepositoryMock) ClearCart(ctx context.Context, userId int64) (err error) {
	mm_atomic.AddUint64(&mmClearCart.beforeClearCartCounter, 1)
	defer mm_atomic.AddUint64(&mmClearCart.afterClearCartCounter, 1)

	mmClearCart.t.Helper()

	if mmClearCart.inspectFuncClearCart != nil {
		mmClearCart.inspectFuncClearCart(ctx, userId)
	}

	mm_params := CartRepositoryMockClearCartParams{ctx, userId}

	// Record call args
	mmClearCart.ClearCartMock.mutex.Lock()
	mmClearCart.ClearCartMock.callArgs = append(mmClearCart.ClearCartMock.callArgs, &mm_params)
	mmClearCart.ClearCartMock.mutex.Unlock()

	for _, e := range mmClearCart.ClearCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmClearCart.ClearCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClearCart.ClearCartMock.defaultExpectation.Counter, 1)
		mm_want := mmClearCart.ClearCartMock.defaultExpectation.params
		mm_want_ptrs := mmClearCart.ClearCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockClearCartParams{ctx, userId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmClearCart.t.Errorf("CartRepositoryMock.ClearCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClearCart.ClearCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmClearCart.t.Errorf("CartRepositoryMock.ClearCart got unexpected parameter userId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClearCart.ClearCartMock.defaultExpectation.expectationOrigins.originUserId, *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmClearCart.t.Errorf("CartRepositoryMock.ClearCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmClearCart.ClearCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmClearCart.ClearCartMock.defaultExpectation.results
		if mm_results == nil {
			mmClearCart.t.Fatal("No results are set for the CartRepositoryMock.ClearCart")
		}
		return (*mm_results).err
	}
	if mmClearCart.funcClearCart != nil {
		return mmClearCart.funcClearCart(ctx, userId)
	}
	mmClearCart.t.Fatalf("Unexpected call to CartRepositoryMock.ClearCart. %v %v", ctx, userId)
	return
}

// ClearCartAfterCounter returns a count of finished CartRepositoryMock.ClearCart invocations
func (mmClearCart *CartRepositoryMock) ClearCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearCart.afterClearCartCounter)
}

// ClearCartBeforeCounter returns a count of CartRepositoryMock.ClearCart invocations
func (mmClearCart *CartRepositoryMock) ClearCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearCart.beforeClearCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.ClearCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClearCart *mCartRepositoryMockClearCart) Calls() []*CartRepositoryMockClearCartParams {
	mmClearCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockClearCartParams, len(mmClearCart.callArgs))
	copy(argCopy, mmClearCart.callArgs)

	mmClearCart.mutex.RUnlock()

	return argCopy
}

// MinimockClearCartDone returns true if the count of the ClearCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockClearCartDone() bool {
	if m.ClearCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ClearCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ClearCartMock.invocationsDone()
}

// MinimockClearCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockClearCartInspect() {
	for _, e := range m.ClearCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.ClearCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterClearCartCounter := mm_atomic.LoadUint64(&m.afterClearCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ClearCartMock.defaultExpectation != nil && afterClearCartCounter < 1 {
		if m.ClearCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.ClearCart at\n%s", m.ClearCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.ClearCart at\n%s with params: %#v", m.ClearCartMock.defaultExpectation.expectationOrigins.origin, *m.ClearCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClearCart != nil && afterClearCartCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.ClearCart at\n%s", m.funcClearCartOrigin)
	}

	if !m.ClearCartMock.invocationsDone() && afterClearCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.ClearCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ClearCartMock.expectedInvocations), m.ClearCartMock.expectedInvocationsOrigin, afterClearCartCounter)
	}
}

type mCartRepositoryMockGetCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockGetCartExpectation
	expectations       []*CartRepositoryMockGetCartExpectation

	callArgs []*CartRepositoryMockGetCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockGetCartExpectation specifies expectation struct of the CartRepository.GetCart
type CartRepositoryMockGetCartExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockGetCartParams
	paramPtrs          *CartRepositoryMockGetCartParamPtrs
	expectationOrigins CartRepositoryMockGetCartExpectationOrigins
	results            *CartRepositoryMockGetCartResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockGetCartParams contains parameters of the CartRepository.GetCart
type CartRepositoryMockGetCartParams struct {
	ctx    context.Context
	userId int64
}

// CartRepositoryMockGetCartParamPtrs contains pointers to parameters of the CartRepository.GetCart
type CartRepositoryMockGetCartParamPtrs struct {
	ctx    *context.Context
	userId *int64
}

// CartRepositoryMockGetCartResults contains results of the CartRepository.GetCart
type CartRepositoryMockGetCartResults struct {
	ca1 []model.CartItem
	err error
}

// CartRepositoryMockGetCartOrigins contains origins of expectations of the CartRepository.GetCart
type CartRepositoryMockGetCartExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCart *mCartRepositoryMockGetCart) Optional() *mCartRepositoryMockGetCart {
	mmGetCart.optional = true
	return mmGetCart
}

// Expect sets up expected params for CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) Expect(ctx context.Context, userId int64) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.paramPtrs != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by ExpectParams functions")
	}

	mmGetCart.defaultExpectation.params = &CartRepositoryMockGetCartParams{ctx, userId}
	mmGetCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCart.expectations {
		if minimock.Equal(e.params, mmGetCart.defaultExpectation.params) {
			mmGetCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCart.defaultExpectation.params)
		}
	}

	return mmGetCart
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.params != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Expect")
	}

	if mmGetCart.defaultExpectation.paramPtrs == nil {
		mmGetCart.defaultExpectation.paramPtrs = &CartRepositoryMockGetCartParamPtrs{}
	}
	mmGetCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCart
}

// ExpectUserIdParam2 sets up expected param userId for CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) ExpectUserIdParam2(userId int64) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.params != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Expect")
	}

	if mmGetCart.defaultExpectation.paramPtrs == nil {
		mmGetCart.defaultExpectation.paramPtrs = &CartRepositoryMockGetCartParamPtrs{}
	}
	mmGetCart.defaultExpectation.paramPtrs.userId = &userId
	mmGetCart.defaultExpectation.expectationOrigins.originUserId = minimock.CallerInfo(1)

	return mmGetCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) Inspect(f func(ctx context.Context, userId int64)) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.inspectFuncGetCart != nil {
		mmGetCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.GetCart")
	}

	mmGetCart.mock.inspectFuncGetCart = f

	return mmGetCart
}

// Return sets up results that will be returned by CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) Return(ca1 []model.CartItem, err error) *CartRepositoryMock {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{mock: mmGetCart.mock}
	}
	mmGetCart.defaultExpectation.results = &CartRepositoryMockGetCartResults{ca1, err}
	mmGetCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCart.mock
}

// Set uses given function f to mock the CartRepository.GetCart method
func (mmGetCart *mCartRepositoryMockGetCart) Set(f func(ctx context.Context, userId int64) (ca1 []model.CartItem, err error)) *CartRepositoryMock {
	if mmGetCart.defaultExpectation != nil {
		mmGetCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.GetCart method")
	}

	if len(mmGetCart.expectations) > 0 {
		mmGetCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.GetCart method")
	}

	mmGetCart.mock.funcGetCart = f
	mmGetCart.mock.funcGetCartOrigin = minimock.CallerInfo(1)
	return mmGetCart.mock
}

// When sets expectation for the CartRepository.GetCart which will trigger the result defined by the following
// Then helper
func (mmGetCart *mCartRepositoryMockGetCart) When(ctx context.Context, userId int64) *CartRepositoryMockGetCartExpectation {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockGetCartExpectation{
		mock:               mmGetCart.mock,
		params:             &CartRepositoryMockGetCartParams{ctx, userId},
		expectationOrigins: CartRepositoryMockGetCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCart.expectations = append(mmGetCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.GetCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockGetCartExpectation) Then(ca1 []model.CartItem, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockGetCartResults{ca1, err}
	return e.mock
}

// Times sets number of times CartRepository.GetCart should be invoked
func (mmGetCart *mCartRepositoryMockGetCart) Times(n uint64) *mCartRepositoryMockGetCart {
	if n == 0 {
		mmGetCart.mock.t.Fatalf("Times of CartRepositoryMock.GetCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCart.expectedInvocations, n)
	mmGetCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCart
}

func (mmGetCart *mCartRepositoryMockGetCart) invocationsDone() bool {
	if len(mmGetCart.expectations) == 0 && mmGetCart.defaultExpectation == nil && mmGetCart.mock.funcGetCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCart.mock.afterGetCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCart implements mm_service.CartRepository
func (mmGetCart *CartRepositoryMock) GetCart(ctx context.Context, userId int64) (ca1 []model.CartItem, err error) {
	mm_atomic.AddUint64(&mmGetCart.beforeGetCartCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCart.afterGetCartCounter, 1)

	mmGetCart.t.Helper()

	if mmGetCart.inspectFuncGetCart != nil {
		mmGetCart.inspectFuncGetCart(ctx, userId)
	}

	mm_params := CartRepositoryMockGetCartParams{ctx, userId}

	// Record call args
	mmGetCart.GetCartMock.mutex.Lock()
	mmGetCart.GetCartMock.callArgs = append(mmGetCart.GetCartMock.callArgs, &mm_params)
	mmGetCart.GetCartMock.mutex.Unlock()

	for _, e := range mmGetCart.GetCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.err
		}
	}

	if mmGetCart.GetCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCart.GetCartMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCart.GetCartMock.defaultExpectation.params
		mm_want_ptrs := mmGetCart.GetCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockGetCartParams{ctx, userId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCart.t.Errorf("CartRepositoryMock.GetCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmGetCart.t.Errorf("CartRepositoryMock.GetCart got unexpected parameter userId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.originUserId, *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCart.t.Errorf("CartRepositoryMock.GetCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCart.GetCartMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCart.t.Fatal("No results are set for the CartRepositoryMock.GetCart")
		}
		return (*mm_results).ca1, (*mm_results).err
	}
	if mmGetCart.funcGetCart != nil {
		return mmGetCart.funcGetCart(ctx, userId)
	}
	mmGetCart.t.Fatalf("Unexpected call to CartRepositoryMock.GetCart. %v %v", ctx, userId)
	return
}

// GetCartAfterCounter returns a count of finished CartRepositoryMock.GetCart invocations
func (mmGetCart *CartRepositoryMock) GetCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.afterGetCartCounter)
}

// GetCartBeforeCounter returns a count of CartRepositoryMock.GetCart invocations
func (mmGetCart *CartRepositoryMock) GetCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.beforeGetCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.GetCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCart *mCartRepositoryMockGetCart) Calls() []*CartRepositoryMockGetCartParams {
	mmGetCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockGetCartParams, len(mmGetCart.callArgs))
	copy(argCopy, mmGetCart.callArgs)

	mmGetCart.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartDone returns true if the count of the GetCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockGetCartDone() bool {
	if m.GetCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCartMock.invocationsDone()
}

// MinimockGetCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockGetCartInspect() {
	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCartCounter := mm_atomic.LoadUint64(&m.afterGetCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartMock.defaultExpectation != nil && afterGetCartCounter < 1 {
		if m.GetCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCart at\n%s", m.GetCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCart at\n%s with params: %#v", m.GetCartMock.defaultExpectation.expectationOrigins.origin, *m.GetCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCart != nil && afterGetCartCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.GetCart at\n%s", m.funcGetCartOrigin)
	}

	if !m.GetCartMock.invocationsDone() && afterGetCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.GetCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCartMock.expectedInvocations), m.GetCartMock.expectedInvocationsOrigin, afterGetCartCounter)
	}
}

type mCartRepositoryMockRemoveItem struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockRemoveItemExpectation
	expectations       []*CartRepositoryMockRemoveItemExpectation

	callArgs []*CartRepositoryMockRemoveItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockRemoveItemExpectation specifies expectation struct of the CartRepository.RemoveItem
type CartRepositoryMockRemoveItemExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockRemoveItemParams
	paramPtrs          *CartRepositoryMockRemoveItemParamPtrs
	expectationOrigins CartRepositoryMockRemoveItemExpectationOrigins
	results            *CartRepositoryMockRemoveItemResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockRemoveItemParams contains parameters of the CartRepository.RemoveItem
type CartRepositoryMockRemoveItemParams struct {
	ctx    context.Context
	userId int64
	sku    int64
}

// CartRepositoryMockRemoveItemParamPtrs contains pointers to parameters of the CartRepository.RemoveItem
type CartRepositoryMockRemoveItemParamPtrs struct {
	ctx    *context.Context
	userId *int64
	sku    *int64
}

// CartRepositoryMockRemoveItemResults contains results of the CartRepository.RemoveItem
type CartRepositoryMockRemoveItemResults struct {
	err error
}

// CartRepositoryMockRemoveItemOrigins contains origins of expectations of the CartRepository.RemoveItem
type CartRepositoryMockRemoveItemExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserId string
	originSku    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveItem *mCartRepositoryMockRemoveItem) Optional() *mCartRepositoryMockRemoveItem {
	mmRemoveItem.optional = true
	return mmRemoveItem
}

// Expect sets up expected params for CartRepository.RemoveItem
func (mmRemoveItem *mCartRepositoryMockRemoveItem) Expect(ctx context.Context, userId int64, sku int64) *mCartRepositoryMockRemoveItem {
	if mmRemoveItem.mock.funcRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Set")
	}

	if mmRemoveItem.defaultExpectation == nil {
		mmRemoveItem.defaultExpectation = &CartRepositoryMockRemoveItemExpectation{}
	}

	if mmRemoveItem.defaultExpectation.paramPtrs != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by ExpectParams functions")
	}

	mmRemoveItem.defaultExpectation.params = &CartRepositoryMockRemoveItemParams{ctx, userId, sku}
	mmRemoveItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveItem.expectations {
		if minimock.Equal(e.params, mmRemoveItem.defaultExpectation.params) {
			mmRemoveItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveItem.defaultExpectation.params)
		}
	}

	return mmRemoveItem
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.RemoveItem
func (mmRemoveItem *mCartRepositoryMockRemoveItem) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockRemoveItem {
	if mmRemoveItem.mock.funcRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Set")
	}

	if mmRemoveItem.defaultExpectation == nil {
		mmRemoveItem.defaultExpectation = &CartRepositoryMockRemoveItemExpectation{}
	}

	if mmRemoveItem.defaultExpectation.params != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Expect")
	}

	if mmRemoveItem.defaultExpectation.paramPtrs == nil {
		mmRemoveItem.defaultExpectation.paramPtrs = &CartRepositoryMockRemoveItemParamPtrs{}
	}
	mmRemoveItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveItem
}

// ExpectUserIdParam2 sets up expected param userId for CartRepository.RemoveItem
func (mmRemoveItem *mCartRepositoryMockRemoveItem) ExpectUserIdParam2(userId int64) *mCartRepositoryMockRemoveItem {
	if mmRemoveItem.mock.funcRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Set")
	}

	if mmRemoveItem.defaultExpectation == nil {
		mmRemoveItem.defaultExpectation = &CartRepositoryMockRemoveItemExpectation{}
	}

	if mmRemoveItem.defaultExpectation.params != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Expect")
	}

	if mmRemoveItem.defaultExpectation.paramPtrs == nil {
		mmRemoveItem.defaultExpectation.paramPtrs = &CartRepositoryMockRemoveItemParamPtrs{}
	}
	mmRemoveItem.defaultExpectation.paramPtrs.userId = &userId
	mmRemoveItem.defaultExpectation.expectationOrigins.originUserId = minimock.CallerInfo(1)

	return mmRemoveItem
}

// ExpectSkuParam3 sets up expected param sku for CartRepository.RemoveItem
func (mmRemoveItem *mCartRepositoryMockRemoveItem) ExpectSkuParam3(sku int64) *mCartRepositoryMockRemoveItem {
	if mmRemoveItem.mock.funcRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Set")
	}

	if mmRemoveItem.defaultExpectation == nil {
		mmRemoveItem.defaultExpectation = &CartRepositoryMockRemoveItemExpectation{}
	}

	if mmRemoveItem.defaultExpectation.params != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Expect")
	}

	if mmRemoveItem.defaultExpectation.paramPtrs == nil {
		mmRemoveItem.defaultExpectation.paramPtrs = &CartRepositoryMockRemoveItemParamPtrs{}
	}
	mmRemoveItem.defaultExpectation.paramPtrs.sku = &sku
	mmRemoveItem.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmRemoveItem
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.RemoveItem
func (mmRemoveItem *mCartRepositoryMockRemoveItem) Inspect(f func(ctx context.Context, userId int64, sku int64)) *mCartRepositoryMockRemoveItem {
	if mmRemoveItem.mock.inspectFuncRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.RemoveItem")
	}

	mmRemoveItem.mock.inspectFuncRemoveItem = f

	return mmRemoveItem
}

// Return sets up results that will be returned by CartRepository.RemoveItem
func (mmRemoveItem *mCartRepositoryMockRemoveItem) Return(err error) *CartRepositoryMock {
	if mmRemoveItem.mock.funcRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Set")
	}

	if mmRemoveItem.defaultExpectation == nil {
		mmRemoveItem.defaultExpectation = &CartRepositoryMockRemoveItemExpectation{mock: mmRemoveItem.mock}
	}
	mmRemoveItem.defaultExpectation.results = &CartRepositoryMockRemoveItemResults{err}
	mmRemoveItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveItem.mock
}

// Set uses given function f to mock the CartRepository.RemoveItem method
func (mmRemoveItem *mCartRepositoryMockRemoveItem) Set(f func(ctx context.Context, userId int64, sku int64) (err error)) *CartRepositoryMock {
	if mmRemoveItem.defaultExpectation != nil {
		mmRemoveItem.mock.t.Fatalf("Default expectation is already set for the CartRepository.RemoveItem method")
	}

	if len(mmRemoveItem.expectations) > 0 {
		mmRemoveItem.mock.t.Fatalf("Some expectations are already set for the CartRepository.RemoveItem method")
	}

	mmRemoveItem.mock.funcRemoveItem = f
	mmRemoveItem.mock.funcRemoveItemOrigin = minimock.CallerInfo(1)
	return mmRemoveItem.mock
}

// When sets expectation for the CartRepository.RemoveItem which will trigger the result defined by the following
// Then helper
func (mmRemoveItem *mCartRepositoryMockRemoveItem) When(ctx context.Context, userId int64, sku int64) *CartRepositoryMockRemoveItemExpectation {
	if mmRemoveItem.mock.funcRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Set")
	}

	expectation := &CartRepositoryMockRemoveItemExpectation{
		mock:               mmRemoveItem.mock,
		params:             &CartRepositoryMockRemoveItemParams{ctx, userId, sku},
		expectationOrigins: CartRepositoryMockRemoveItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveItem.expectations = append(mmRemoveItem.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.RemoveItem return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockRemoveItemExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockRemoveItemResults{err}
	return e.mock
}

// Times sets number of times CartRepository.RemoveItem should be invoked
func (mmRemoveItem *mCartRepositoryMockRemoveItem) Times(n uint64) *mCartRepositoryMockRemoveItem {
	if n == 0 {
		mmRemoveItem.mock.t.Fatalf("Times of CartRepositoryMock.RemoveItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveItem.expectedInvocations, n)
	mmRemoveItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveItem
}

func (mmRemoveItem *mCartRepositoryMockRemoveItem) invocationsDone() bool {
	if len(mmRemoveItem.expectations) == 0 && mmRemoveItem.defaultExpectation == nil && mmRemoveItem.mock.funcRemoveItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveItem.mock.afterRemoveItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveItem implements mm_service.CartRepository
func (mmRemoveItem *CartRepositoryMock) RemoveItem(ctx context.Context, userId int64, sku int64) (err error) {
	mm_atomic.AddUint64(&mmRemoveItem.beforeRemoveItemCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveItem.afterRemoveItemCounter, 1)

	mmRemoveItem.t.Helper()

	if mmRemoveItem.inspectFuncRemoveItem != nil {
		mmRemoveItem.inspectFuncRemoveItem(ctx, userId, sku)
	}

	mm_params := CartRepositoryMockRemoveItemParams{ctx, userId, sku}

	// Record call args
	mmRemoveItem.RemoveItemMock.mutex.Lock()
	mmRemoveItem.RemoveItemMock.callArgs = append(mmRemoveItem.RemoveItemMock.callArgs, &mm_params)
	mmRemoveItem.RemoveItemMock.mutex.Unlock()

	for _, e := range mmRemoveItem.RemoveItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveItem.RemoveItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveItem.RemoveItemMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveItem.RemoveItemMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveItem.RemoveItemMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockRemoveItemParams{ctx, userId, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveItem.t.Errorf("CartRepositoryMock.RemoveItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveItem.RemoveItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmRemoveItem.t.Errorf("CartRepositoryMock.RemoveItem got unexpected parameter userId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveItem.RemoveItemMock.defaultExpectation.expectationOrigins.originUserId, *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmRemoveItem.t.Errorf("CartRepositoryMock.RemoveItem got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveItem.RemoveItemMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveItem.t.Errorf("CartRepositoryMock.RemoveItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveItem.RemoveItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveItem.RemoveItemMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveItem.t.Fatal("No results are set for the CartRepositoryMock.RemoveItem")
		}
		return (*mm_results).err
	}
	if mmRemoveItem.funcRemoveItem != nil {
		return mmRemoveItem.funcRemoveItem(ctx, userId, sku)
	}
	mmRemoveItem.t.Fatalf("Unexpected call to CartRepositoryMock.RemoveItem. %v %v %v", ctx, userId, sku)
	return
}

// RemoveItemAfterCounter returns a count of finished CartRepositoryMock.RemoveItem invocations
func (mmRemoveItem *CartRepositoryMock) RemoveItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveItem.afterRemoveItemCounter)
}

// RemoveItemBeforeCounter returns a count of CartRepositoryMock.RemoveItem invocations
func (mmRemoveItem *CartRepositoryMock) RemoveItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveItem.beforeRemoveItemCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.RemoveItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveItem *mCartRepositoryMockRemoveItem) Calls() []*CartRepositoryMockRemoveItemParams {
	mmRemoveItem.mutex.RLock()

	argCopy := make([]*CartRepositoryMockRemoveItemParams, len(mmRemoveItem.callArgs))
	copy(argCopy, mmRemoveItem.callArgs)

	mmRemoveItem.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveItemDone returns true if the count of the RemoveItem invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockRemoveItemDone() bool {
	if m.RemoveItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveItemMock.invocationsDone()
}

// MinimockRemoveItemInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockRemoveItemInspect() {
	for _, e := range m.RemoveItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.RemoveItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveItemCounter := mm_atomic.LoadUint64(&m.afterRemoveItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveItemMock.defaultExpectation != nil && afterRemoveItemCounter < 1 {
		if m.RemoveItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.RemoveItem at\n%s", m.RemoveItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.RemoveItem at\n%s with params: %#v", m.RemoveItemMock.defaultExpectation.expectationOrigins.origin, *m.RemoveItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveItem != nil && afterRemoveItemCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.RemoveItem at\n%s", m.funcRemoveItemOrigin)
	}

	if !m.RemoveItemMock.invocationsDone() && afterRemoveItemCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.RemoveItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveItemMock.expectedInvocations), m.RemoveItemMock.expectedInvocationsOrigin, afterRemoveItemCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddItemInspect()

			m.MinimockClearCartInspect()

			m.MinimockGetCartInspect()

			m.MinimockRemoveItemInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddItemDone() &&
		m.MinimockClearCartDone() &&
		m.MinimockGetCartDone() &&
		m.MinimockRemoveItemDone()
}
