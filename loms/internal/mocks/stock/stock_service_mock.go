// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package stock

//go:generate minimock -i gitlab.ozon.dev/kanat_9999/homework/loms/internal/service/stock.Repository -o stock_service_mock.go -n RepositoryMock -p stock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RepositoryMock implements mm_stock.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetBySKU          func(ctx context.Context, sku uint32) (u1 uint64, err error)
	funcGetBySKUOrigin    string
	inspectFuncGetBySKU   func(ctx context.Context, sku uint32)
	afterGetBySKUCounter  uint64
	beforeGetBySKUCounter uint64
	GetBySKUMock          mRepositoryMockGetBySKU

	funcRelease          func(ctx context.Context, sku uint32, count uint16) (err error)
	funcReleaseOrigin    string
	inspectFuncRelease   func(ctx context.Context, sku uint32, count uint16)
	afterReleaseCounter  uint64
	beforeReleaseCounter uint64
	ReleaseMock          mRepositoryMockRelease

	funcReserve          func(ctx context.Context, sku uint32, count uint16) (err error)
	funcReserveOrigin    string
	inspectFuncReserve   func(ctx context.Context, sku uint32, count uint16)
	afterReserveCounter  uint64
	beforeReserveCounter uint64
	ReserveMock          mRepositoryMockReserve

	funcReserveRemove          func(ctx context.Context, sku uint32, count uint16) (err error)
	funcReserveRemoveOrigin    string
	inspectFuncReserveRemove   func(ctx context.Context, sku uint32, count uint16)
	afterReserveRemoveCounter  uint64
	beforeReserveRemoveCounter uint64
	ReserveRemoveMock          mRepositoryMockReserveRemove
}

// NewRepositoryMock returns a mock for mm_stock.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetBySKUMock = mRepositoryMockGetBySKU{mock: m}
	m.GetBySKUMock.callArgs = []*RepositoryMockGetBySKUParams{}

	m.ReleaseMock = mRepositoryMockRelease{mock: m}
	m.ReleaseMock.callArgs = []*RepositoryMockReleaseParams{}

	m.ReserveMock = mRepositoryMockReserve{mock: m}
	m.ReserveMock.callArgs = []*RepositoryMockReserveParams{}

	m.ReserveRemoveMock = mRepositoryMockReserveRemove{mock: m}
	m.ReserveRemoveMock.callArgs = []*RepositoryMockReserveRemoveParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockGetBySKU struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetBySKUExpectation
	expectations       []*RepositoryMockGetBySKUExpectation

	callArgs []*RepositoryMockGetBySKUParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetBySKUExpectation specifies expectation struct of the Repository.GetBySKU
type RepositoryMockGetBySKUExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetBySKUParams
	paramPtrs          *RepositoryMockGetBySKUParamPtrs
	expectationOrigins RepositoryMockGetBySKUExpectationOrigins
	results            *RepositoryMockGetBySKUResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetBySKUParams contains parameters of the Repository.GetBySKU
type RepositoryMockGetBySKUParams struct {
	ctx context.Context
	sku uint32
}

// RepositoryMockGetBySKUParamPtrs contains pointers to parameters of the Repository.GetBySKU
type RepositoryMockGetBySKUParamPtrs struct {
	ctx *context.Context
	sku *uint32
}

// RepositoryMockGetBySKUResults contains results of the Repository.GetBySKU
type RepositoryMockGetBySKUResults struct {
	u1  uint64
	err error
}

// RepositoryMockGetBySKUOrigins contains origins of expectations of the Repository.GetBySKU
type RepositoryMockGetBySKUExpectationOrigins struct {
	origin    string
	originCtx string
	originSku string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBySKU *mRepositoryMockGetBySKU) Optional() *mRepositoryMockGetBySKU {
	mmGetBySKU.optional = true
	return mmGetBySKU
}

// Expect sets up expected params for Repository.GetBySKU
func (mmGetBySKU *mRepositoryMockGetBySKU) Expect(ctx context.Context, sku uint32) *mRepositoryMockGetBySKU {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("RepositoryMock.GetBySKU mock is already set by Set")
	}

	if mmGetBySKU.defaultExpectation == nil {
		mmGetBySKU.defaultExpectation = &RepositoryMockGetBySKUExpectation{}
	}

	if mmGetBySKU.defaultExpectation.paramPtrs != nil {
		mmGetBySKU.mock.t.Fatalf("RepositoryMock.GetBySKU mock is already set by ExpectParams functions")
	}

	mmGetBySKU.defaultExpectation.params = &RepositoryMockGetBySKUParams{ctx, sku}
	mmGetBySKU.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetBySKU.expectations {
		if minimock.Equal(e.params, mmGetBySKU.defaultExpectation.params) {
			mmGetBySKU.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBySKU.defaultExpectation.params)
		}
	}

	return mmGetBySKU
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetBySKU
func (mmGetBySKU *mRepositoryMockGetBySKU) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetBySKU {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("RepositoryMock.GetBySKU mock is already set by Set")
	}

	if mmGetBySKU.defaultExpectation == nil {
		mmGetBySKU.defaultExpectation = &RepositoryMockGetBySKUExpectation{}
	}

	if mmGetBySKU.defaultExpectation.params != nil {
		mmGetBySKU.mock.t.Fatalf("RepositoryMock.GetBySKU mock is already set by Expect")
	}

	if mmGetBySKU.defaultExpectation.paramPtrs == nil {
		mmGetBySKU.defaultExpectation.paramPtrs = &RepositoryMockGetBySKUParamPtrs{}
	}
	mmGetBySKU.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetBySKU.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetBySKU
}

// ExpectSkuParam2 sets up expected param sku for Repository.GetBySKU
func (mmGetBySKU *mRepositoryMockGetBySKU) ExpectSkuParam2(sku uint32) *mRepositoryMockGetBySKU {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("RepositoryMock.GetBySKU mock is already set by Set")
	}

	if mmGetBySKU.defaultExpectation == nil {
		mmGetBySKU.defaultExpectation = &RepositoryMockGetBySKUExpectation{}
	}

	if mmGetBySKU.defaultExpectation.params != nil {
		mmGetBySKU.mock.t.Fatalf("RepositoryMock.GetBySKU mock is already set by Expect")
	}

	if mmGetBySKU.defaultExpectation.paramPtrs == nil {
		mmGetBySKU.defaultExpectation.paramPtrs = &RepositoryMockGetBySKUParamPtrs{}
	}
	mmGetBySKU.defaultExpectation.paramPtrs.sku = &sku
	mmGetBySKU.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmGetBySKU
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetBySKU
func (mmGetBySKU *mRepositoryMockGetBySKU) Inspect(f func(ctx context.Context, sku uint32)) *mRepositoryMockGetBySKU {
	if mmGetBySKU.mock.inspectFuncGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetBySKU")
	}

	mmGetBySKU.mock.inspectFuncGetBySKU = f

	return mmGetBySKU
}

// Return sets up results that will be returned by Repository.GetBySKU
func (mmGetBySKU *mRepositoryMockGetBySKU) Return(u1 uint64, err error) *RepositoryMock {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("RepositoryMock.GetBySKU mock is already set by Set")
	}

	if mmGetBySKU.defaultExpectation == nil {
		mmGetBySKU.defaultExpectation = &RepositoryMockGetBySKUExpectation{mock: mmGetBySKU.mock}
	}
	mmGetBySKU.defaultExpectation.results = &RepositoryMockGetBySKUResults{u1, err}
	mmGetBySKU.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetBySKU.mock
}

// Set uses given function f to mock the Repository.GetBySKU method
func (mmGetBySKU *mRepositoryMockGetBySKU) Set(f func(ctx context.Context, sku uint32) (u1 uint64, err error)) *RepositoryMock {
	if mmGetBySKU.defaultExpectation != nil {
		mmGetBySKU.mock.t.Fatalf("Default expectation is already set for the Repository.GetBySKU method")
	}

	if len(mmGetBySKU.expectations) > 0 {
		mmGetBySKU.mock.t.Fatalf("Some expectations are already set for the Repository.GetBySKU method")
	}

	mmGetBySKU.mock.funcGetBySKU = f
	mmGetBySKU.mock.funcGetBySKUOrigin = minimock.CallerInfo(1)
	return mmGetBySKU.mock
}

// When sets expectation for the Repository.GetBySKU which will trigger the result defined by the following
// Then helper
func (mmGetBySKU *mRepositoryMockGetBySKU) When(ctx context.Context, sku uint32) *RepositoryMockGetBySKUExpectation {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("RepositoryMock.GetBySKU mock is already set by Set")
	}

	expectation := &RepositoryMockGetBySKUExpectation{
		mock:               mmGetBySKU.mock,
		params:             &RepositoryMockGetBySKUParams{ctx, sku},
		expectationOrigins: RepositoryMockGetBySKUExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetBySKU.expectations = append(mmGetBySKU.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetBySKU return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetBySKUExpectation) Then(u1 uint64, err error) *RepositoryMock {
	e.results = &RepositoryMockGetBySKUResults{u1, err}
	return e.mock
}

// Times sets number of times Repository.GetBySKU should be invoked
func (mmGetBySKU *mRepositoryMockGetBySKU) Times(n uint64) *mRepositoryMockGetBySKU {
	if n == 0 {
		mmGetBySKU.mock.t.Fatalf("Times of RepositoryMock.GetBySKU mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetBySKU.expectedInvocations, n)
	mmGetBySKU.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetBySKU
}

func (mmGetBySKU *mRepositoryMockGetBySKU) invocationsDone() bool {
	if len(mmGetBySKU.expectations) == 0 && mmGetBySKU.defaultExpectation == nil && mmGetBySKU.mock.funcGetBySKU == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetBySKU.mock.afterGetBySKUCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetBySKU.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetBySKU implements mm_stock.Repository
func (mmGetBySKU *RepositoryMock) GetBySKU(ctx context.Context, sku uint32) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmGetBySKU.beforeGetBySKUCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBySKU.afterGetBySKUCounter, 1)

	mmGetBySKU.t.Helper()

	if mmGetBySKU.inspectFuncGetBySKU != nil {
		mmGetBySKU.inspectFuncGetBySKU(ctx, sku)
	}

	mm_params := RepositoryMockGetBySKUParams{ctx, sku}

	// Record call args
	mmGetBySKU.GetBySKUMock.mutex.Lock()
	mmGetBySKU.GetBySKUMock.callArgs = append(mmGetBySKU.GetBySKUMock.callArgs, &mm_params)
	mmGetBySKU.GetBySKUMock.mutex.Unlock()

	for _, e := range mmGetBySKU.GetBySKUMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetBySKU.GetBySKUMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBySKU.GetBySKUMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBySKU.GetBySKUMock.defaultExpectation.params
		mm_want_ptrs := mmGetBySKU.GetBySKUMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetBySKUParams{ctx, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetBySKU.t.Errorf("RepositoryMock.GetBySKU got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBySKU.GetBySKUMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmGetBySKU.t.Errorf("RepositoryMock.GetBySKU got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBySKU.GetBySKUMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBySKU.t.Errorf("RepositoryMock.GetBySKU got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetBySKU.GetBySKUMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBySKU.GetBySKUMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBySKU.t.Fatal("No results are set for the RepositoryMock.GetBySKU")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetBySKU.funcGetBySKU != nil {
		return mmGetBySKU.funcGetBySKU(ctx, sku)
	}
	mmGetBySKU.t.Fatalf("Unexpected call to RepositoryMock.GetBySKU. %v %v", ctx, sku)
	return
}

// GetBySKUAfterCounter returns a count of finished RepositoryMock.GetBySKU invocations
func (mmGetBySKU *RepositoryMock) GetBySKUAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBySKU.afterGetBySKUCounter)
}

// GetBySKUBeforeCounter returns a count of RepositoryMock.GetBySKU invocations
func (mmGetBySKU *RepositoryMock) GetBySKUBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBySKU.beforeGetBySKUCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetBySKU.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBySKU *mRepositoryMockGetBySKU) Calls() []*RepositoryMockGetBySKUParams {
	mmGetBySKU.mutex.RLock()

	argCopy := make([]*RepositoryMockGetBySKUParams, len(mmGetBySKU.callArgs))
	copy(argCopy, mmGetBySKU.callArgs)

	mmGetBySKU.mutex.RUnlock()

	return argCopy
}

// MinimockGetBySKUDone returns true if the count of the GetBySKU invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetBySKUDone() bool {
	if m.GetBySKUMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetBySKUMock.invocationsDone()
}

// MinimockGetBySKUInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetBySKUInspect() {
	for _, e := range m.GetBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetBySKU at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetBySKUCounter := mm_atomic.LoadUint64(&m.afterGetBySKUCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetBySKUMock.defaultExpectation != nil && afterGetBySKUCounter < 1 {
		if m.GetBySKUMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetBySKU at\n%s", m.GetBySKUMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetBySKU at\n%s with params: %#v", m.GetBySKUMock.defaultExpectation.expectationOrigins.origin, *m.GetBySKUMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBySKU != nil && afterGetBySKUCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetBySKU at\n%s", m.funcGetBySKUOrigin)
	}

	if !m.GetBySKUMock.invocationsDone() && afterGetBySKUCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetBySKU at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetBySKUMock.expectedInvocations), m.GetBySKUMock.expectedInvocationsOrigin, afterGetBySKUCounter)
	}
}

type mRepositoryMockRelease struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockReleaseExpectation
	expectations       []*RepositoryMockReleaseExpectation

	callArgs []*RepositoryMockReleaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockReleaseExpectation specifies expectation struct of the Repository.Release
type RepositoryMockReleaseExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockReleaseParams
	paramPtrs          *RepositoryMockReleaseParamPtrs
	expectationOrigins RepositoryMockReleaseExpectationOrigins
	results            *RepositoryMockReleaseResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockReleaseParams contains parameters of the Repository.Release
type RepositoryMockReleaseParams struct {
	ctx   context.Context
	sku   uint32
	count uint16
}

// RepositoryMockReleaseParamPtrs contains pointers to parameters of the Repository.Release
type RepositoryMockReleaseParamPtrs struct {
	ctx   *context.Context
	sku   *uint32
	count *uint16
}

// RepositoryMockReleaseResults contains results of the Repository.Release
type RepositoryMockReleaseResults struct {
	err error
}

// RepositoryMockReleaseOrigins contains origins of expectations of the Repository.Release
type RepositoryMockReleaseExpectationOrigins struct {
	origin      string
	originCtx   string
	originSku   string
	originCount string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRelease *mRepositoryMockRelease) Optional() *mRepositoryMockRelease {
	mmRelease.optional = true
	return mmRelease
}

// Expect sets up expected params for Repository.Release
func (mmRelease *mRepositoryMockRelease) Expect(ctx context.Context, sku uint32, count uint16) *mRepositoryMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("RepositoryMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &RepositoryMockReleaseExpectation{}
	}

	if mmRelease.defaultExpectation.paramPtrs != nil {
		mmRelease.mock.t.Fatalf("RepositoryMock.Release mock is already set by ExpectParams functions")
	}

	mmRelease.defaultExpectation.params = &RepositoryMockReleaseParams{ctx, sku, count}
	mmRelease.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRelease.expectations {
		if minimock.Equal(e.params, mmRelease.defaultExpectation.params) {
			mmRelease.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRelease.defaultExpectation.params)
		}
	}

	return mmRelease
}

// ExpectCtxParam1 sets up expected param ctx for Repository.Release
func (mmRelease *mRepositoryMockRelease) ExpectCtxParam1(ctx context.Context) *mRepositoryMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("RepositoryMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &RepositoryMockReleaseExpectation{}
	}

	if mmRelease.defaultExpectation.params != nil {
		mmRelease.mock.t.Fatalf("RepositoryMock.Release mock is already set by Expect")
	}

	if mmRelease.defaultExpectation.paramPtrs == nil {
		mmRelease.defaultExpectation.paramPtrs = &RepositoryMockReleaseParamPtrs{}
	}
	mmRelease.defaultExpectation.paramPtrs.ctx = &ctx
	mmRelease.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRelease
}

// ExpectSkuParam2 sets up expected param sku for Repository.Release
func (mmRelease *mRepositoryMockRelease) ExpectSkuParam2(sku uint32) *mRepositoryMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("RepositoryMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &RepositoryMockReleaseExpectation{}
	}

	if mmRelease.defaultExpectation.params != nil {
		mmRelease.mock.t.Fatalf("RepositoryMock.Release mock is already set by Expect")
	}

	if mmRelease.defaultExpectation.paramPtrs == nil {
		mmRelease.defaultExpectation.paramPtrs = &RepositoryMockReleaseParamPtrs{}
	}
	mmRelease.defaultExpectation.paramPtrs.sku = &sku
	mmRelease.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmRelease
}

// ExpectCountParam3 sets up expected param count for Repository.Release
func (mmRelease *mRepositoryMockRelease) ExpectCountParam3(count uint16) *mRepositoryMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("RepositoryMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &RepositoryMockReleaseExpectation{}
	}

	if mmRelease.defaultExpectation.params != nil {
		mmRelease.mock.t.Fatalf("RepositoryMock.Release mock is already set by Expect")
	}

	if mmRelease.defaultExpectation.paramPtrs == nil {
		mmRelease.defaultExpectation.paramPtrs = &RepositoryMockReleaseParamPtrs{}
	}
	mmRelease.defaultExpectation.paramPtrs.count = &count
	mmRelease.defaultExpectation.expectationOrigins.originCount = minimock.CallerInfo(1)

	return mmRelease
}

// Inspect accepts an inspector function that has same arguments as the Repository.Release
func (mmRelease *mRepositoryMockRelease) Inspect(f func(ctx context.Context, sku uint32, count uint16)) *mRepositoryMockRelease {
	if mmRelease.mock.inspectFuncRelease != nil {
		mmRelease.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Release")
	}

	mmRelease.mock.inspectFuncRelease = f

	return mmRelease
}

// Return sets up results that will be returned by Repository.Release
func (mmRelease *mRepositoryMockRelease) Return(err error) *RepositoryMock {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("RepositoryMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &RepositoryMockReleaseExpectation{mock: mmRelease.mock}
	}
	mmRelease.defaultExpectation.results = &RepositoryMockReleaseResults{err}
	mmRelease.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRelease.mock
}

// Set uses given function f to mock the Repository.Release method
func (mmRelease *mRepositoryMockRelease) Set(f func(ctx context.Context, sku uint32, count uint16) (err error)) *RepositoryMock {
	if mmRelease.defaultExpectation != nil {
		mmRelease.mock.t.Fatalf("Default expectation is already set for the Repository.Release method")
	}

	if len(mmRelease.expectations) > 0 {
		mmRelease.mock.t.Fatalf("Some expectations are already set for the Repository.Release method")
	}

	mmRelease.mock.funcRelease = f
	mmRelease.mock.funcReleaseOrigin = minimock.CallerInfo(1)
	return mmRelease.mock
}

// When sets expectation for the Repository.Release which will trigger the result defined by the following
// Then helper
func (mmRelease *mRepositoryMockRelease) When(ctx context.Context, sku uint32, count uint16) *RepositoryMockReleaseExpectation {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("RepositoryMock.Release mock is already set by Set")
	}

	expectation := &RepositoryMockReleaseExpectation{
		mock:               mmRelease.mock,
		params:             &RepositoryMockReleaseParams{ctx, sku, count},
		expectationOrigins: RepositoryMockReleaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRelease.expectations = append(mmRelease.expectations, expectation)
	return expectation
}

// Then sets up Repository.Release return parameters for the expectation previously defined by the When method
func (e *RepositoryMockReleaseExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockReleaseResults{err}
	return e.mock
}

// Times sets number of times Repository.Release should be invoked
func (mmRelease *mRepositoryMockRelease) Times(n uint64) *mRepositoryMockRelease {
	if n == 0 {
		mmRelease.mock.t.Fatalf("Times of RepositoryMock.Release mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRelease.expectedInvocations, n)
	mmRelease.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRelease
}

func (mmRelease *mRepositoryMockRelease) invocationsDone() bool {
	if len(mmRelease.expectations) == 0 && mmRelease.defaultExpectation == nil && mmRelease.mock.funcRelease == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRelease.mock.afterReleaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRelease.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Release implements mm_stock.Repository
func (mmRelease *RepositoryMock) Release(ctx context.Context, sku uint32, count uint16) (err error) {
	mm_atomic.AddUint64(&mmRelease.beforeReleaseCounter, 1)
	defer mm_atomic.AddUint64(&mmRelease.afterReleaseCounter, 1)

	mmRelease.t.Helper()

	if mmRelease.inspectFuncRelease != nil {
		mmRelease.inspectFuncRelease(ctx, sku, count)
	}

	mm_params := RepositoryMockReleaseParams{ctx, sku, count}

	// Record call args
	mmRelease.ReleaseMock.mutex.Lock()
	mmRelease.ReleaseMock.callArgs = append(mmRelease.ReleaseMock.callArgs, &mm_params)
	mmRelease.ReleaseMock.mutex.Unlock()

	for _, e := range mmRelease.ReleaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRelease.ReleaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRelease.ReleaseMock.defaultExpectation.Counter, 1)
		mm_want := mmRelease.ReleaseMock.defaultExpectation.params
		mm_want_ptrs := mmRelease.ReleaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockReleaseParams{ctx, sku, count}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRelease.t.Errorf("RepositoryMock.Release got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRelease.ReleaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmRelease.t.Errorf("RepositoryMock.Release got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRelease.ReleaseMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

			if mm_want_ptrs.count != nil && !minimock.Equal(*mm_want_ptrs.count, mm_got.count) {
				mmRelease.t.Errorf("RepositoryMock.Release got unexpected parameter count, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRelease.ReleaseMock.defaultExpectation.expectationOrigins.originCount, *mm_want_ptrs.count, mm_got.count, minimock.Diff(*mm_want_ptrs.count, mm_got.count))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRelease.t.Errorf("RepositoryMock.Release got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRelease.ReleaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRelease.ReleaseMock.defaultExpectation.results
		if mm_results == nil {
			mmRelease.t.Fatal("No results are set for the RepositoryMock.Release")
		}
		return (*mm_results).err
	}
	if mmRelease.funcRelease != nil {
		return mmRelease.funcRelease(ctx, sku, count)
	}
	mmRelease.t.Fatalf("Unexpected call to RepositoryMock.Release. %v %v %v", ctx, sku, count)
	return
}

// ReleaseAfterCounter returns a count of finished RepositoryMock.Release invocations
func (mmRelease *RepositoryMock) ReleaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRelease.afterReleaseCounter)
}

// ReleaseBeforeCounter returns a count of RepositoryMock.Release invocations
func (mmRelease *RepositoryMock) ReleaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRelease.beforeReleaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Release.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRelease *mRepositoryMockRelease) Calls() []*RepositoryMockReleaseParams {
	mmRelease.mutex.RLock()

	argCopy := make([]*RepositoryMockReleaseParams, len(mmRelease.callArgs))
	copy(argCopy, mmRelease.callArgs)

	mmRelease.mutex.RUnlock()

	return argCopy
}

// MinimockReleaseDone returns true if the count of the Release invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockReleaseDone() bool {
	if m.ReleaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReleaseMock.invocationsDone()
}

// MinimockReleaseInspect logs each unmet expectation
func (m *RepositoryMock) MinimockReleaseInspect() {
	for _, e := range m.ReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.Release at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReleaseCounter := mm_atomic.LoadUint64(&m.afterReleaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReleaseMock.defaultExpectation != nil && afterReleaseCounter < 1 {
		if m.ReleaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.Release at\n%s", m.ReleaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.Release at\n%s with params: %#v", m.ReleaseMock.defaultExpectation.expectationOrigins.origin, *m.ReleaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRelease != nil && afterReleaseCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.Release at\n%s", m.funcReleaseOrigin)
	}

	if !m.ReleaseMock.invocationsDone() && afterReleaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.Release at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReleaseMock.expectedInvocations), m.ReleaseMock.expectedInvocationsOrigin, afterReleaseCounter)
	}
}

type mRepositoryMockReserve struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockReserveExpectation
	expectations       []*RepositoryMockReserveExpectation

	callArgs []*RepositoryMockReserveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockReserveExpectation specifies expectation struct of the Repository.Reserve
type RepositoryMockReserveExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockReserveParams
	paramPtrs          *RepositoryMockReserveParamPtrs
	expectationOrigins RepositoryMockReserveExpectationOrigins
	results            *RepositoryMockReserveResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockReserveParams contains parameters of the Repository.Reserve
type RepositoryMockReserveParams struct {
	ctx   context.Context
	sku   uint32
	count uint16
}

// RepositoryMockReserveParamPtrs contains pointers to parameters of the Repository.Reserve
type RepositoryMockReserveParamPtrs struct {
	ctx   *context.Context
	sku   *uint32
	count *uint16
}

// RepositoryMockReserveResults contains results of the Repository.Reserve
type RepositoryMockReserveResults struct {
	err error
}

// RepositoryMockReserveOrigins contains origins of expectations of the Repository.Reserve
type RepositoryMockReserveExpectationOrigins struct {
	origin      string
	originCtx   string
	originSku   string
	originCount string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserve *mRepositoryMockReserve) Optional() *mRepositoryMockReserve {
	mmReserve.optional = true
	return mmReserve
}

// Expect sets up expected params for Repository.Reserve
func (mmReserve *mRepositoryMockReserve) Expect(ctx context.Context, sku uint32, count uint16) *mRepositoryMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("RepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &RepositoryMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.paramPtrs != nil {
		mmReserve.mock.t.Fatalf("RepositoryMock.Reserve mock is already set by ExpectParams functions")
	}

	mmReserve.defaultExpectation.params = &RepositoryMockReserveParams{ctx, sku, count}
	mmReserve.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReserve.expectations {
		if minimock.Equal(e.params, mmReserve.defaultExpectation.params) {
			mmReserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserve.defaultExpectation.params)
		}
	}

	return mmReserve
}

// ExpectCtxParam1 sets up expected param ctx for Repository.Reserve
func (mmReserve *mRepositoryMockReserve) ExpectCtxParam1(ctx context.Context) *mRepositoryMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("RepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &RepositoryMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("RepositoryMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &RepositoryMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.ctx = &ctx
	mmReserve.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReserve
}

// ExpectSkuParam2 sets up expected param sku for Repository.Reserve
func (mmReserve *mRepositoryMockReserve) ExpectSkuParam2(sku uint32) *mRepositoryMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("RepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &RepositoryMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("RepositoryMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &RepositoryMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.sku = &sku
	mmReserve.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmReserve
}

// ExpectCountParam3 sets up expected param count for Repository.Reserve
func (mmReserve *mRepositoryMockReserve) ExpectCountParam3(count uint16) *mRepositoryMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("RepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &RepositoryMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("RepositoryMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &RepositoryMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.count = &count
	mmReserve.defaultExpectation.expectationOrigins.originCount = minimock.CallerInfo(1)

	return mmReserve
}

// Inspect accepts an inspector function that has same arguments as the Repository.Reserve
func (mmReserve *mRepositoryMockReserve) Inspect(f func(ctx context.Context, sku uint32, count uint16)) *mRepositoryMockReserve {
	if mmReserve.mock.inspectFuncReserve != nil {
		mmReserve.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Reserve")
	}

	mmReserve.mock.inspectFuncReserve = f

	return mmReserve
}

// Return sets up results that will be returned by Repository.Reserve
func (mmReserve *mRepositoryMockReserve) Return(err error) *RepositoryMock {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("RepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &RepositoryMockReserveExpectation{mock: mmReserve.mock}
	}
	mmReserve.defaultExpectation.results = &RepositoryMockReserveResults{err}
	mmReserve.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReserve.mock
}

// Set uses given function f to mock the Repository.Reserve method
func (mmReserve *mRepositoryMockReserve) Set(f func(ctx context.Context, sku uint32, count uint16) (err error)) *RepositoryMock {
	if mmReserve.defaultExpectation != nil {
		mmReserve.mock.t.Fatalf("Default expectation is already set for the Repository.Reserve method")
	}

	if len(mmReserve.expectations) > 0 {
		mmReserve.mock.t.Fatalf("Some expectations are already set for the Repository.Reserve method")
	}

	mmReserve.mock.funcReserve = f
	mmReserve.mock.funcReserveOrigin = minimock.CallerInfo(1)
	return mmReserve.mock
}

// When sets expectation for the Repository.Reserve which will trigger the result defined by the following
// Then helper
func (mmReserve *mRepositoryMockReserve) When(ctx context.Context, sku uint32, count uint16) *RepositoryMockReserveExpectation {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("RepositoryMock.Reserve mock is already set by Set")
	}

	expectation := &RepositoryMockReserveExpectation{
		mock:               mmReserve.mock,
		params:             &RepositoryMockReserveParams{ctx, sku, count},
		expectationOrigins: RepositoryMockReserveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReserve.expectations = append(mmReserve.expectations, expectation)
	return expectation
}

// Then sets up Repository.Reserve return parameters for the expectation previously defined by the When method
func (e *RepositoryMockReserveExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockReserveResults{err}
	return e.mock
}

// Times sets number of times Repository.Reserve should be invoked
func (mmReserve *mRepositoryMockReserve) Times(n uint64) *mRepositoryMockReserve {
	if n == 0 {
		mmReserve.mock.t.Fatalf("Times of RepositoryMock.Reserve mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserve.expectedInvocations, n)
	mmReserve.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReserve
}

func (mmReserve *mRepositoryMockReserve) invocationsDone() bool {
	if len(mmReserve.expectations) == 0 && mmReserve.defaultExpectation == nil && mmReserve.mock.funcReserve == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserve.mock.afterReserveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserve.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Reserve implements mm_stock.Repository
func (mmReserve *RepositoryMock) Reserve(ctx context.Context, sku uint32, count uint16) (err error) {
	mm_atomic.AddUint64(&mmReserve.beforeReserveCounter, 1)
	defer mm_atomic.AddUint64(&mmReserve.afterReserveCounter, 1)

	mmReserve.t.Helper()

	if mmReserve.inspectFuncReserve != nil {
		mmReserve.inspectFuncReserve(ctx, sku, count)
	}

	mm_params := RepositoryMockReserveParams{ctx, sku, count}

	// Record call args
	mmReserve.ReserveMock.mutex.Lock()
	mmReserve.ReserveMock.callArgs = append(mmReserve.ReserveMock.callArgs, &mm_params)
	mmReserve.ReserveMock.mutex.Unlock()

	for _, e := range mmReserve.ReserveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserve.ReserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserve.ReserveMock.defaultExpectation.Counter, 1)
		mm_want := mmReserve.ReserveMock.defaultExpectation.params
		mm_want_ptrs := mmReserve.ReserveMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockReserveParams{ctx, sku, count}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserve.t.Errorf("RepositoryMock.Reserve got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserve.ReserveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmReserve.t.Errorf("RepositoryMock.Reserve got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserve.ReserveMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

			if mm_want_ptrs.count != nil && !minimock.Equal(*mm_want_ptrs.count, mm_got.count) {
				mmReserve.t.Errorf("RepositoryMock.Reserve got unexpected parameter count, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserve.ReserveMock.defaultExpectation.expectationOrigins.originCount, *mm_want_ptrs.count, mm_got.count, minimock.Diff(*mm_want_ptrs.count, mm_got.count))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserve.t.Errorf("RepositoryMock.Reserve got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReserve.ReserveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserve.ReserveMock.defaultExpectation.results
		if mm_results == nil {
			mmReserve.t.Fatal("No results are set for the RepositoryMock.Reserve")
		}
		return (*mm_results).err
	}
	if mmReserve.funcReserve != nil {
		return mmReserve.funcReserve(ctx, sku, count)
	}
	mmReserve.t.Fatalf("Unexpected call to RepositoryMock.Reserve. %v %v %v", ctx, sku, count)
	return
}

// ReserveAfterCounter returns a count of finished RepositoryMock.Reserve invocations
func (mmReserve *RepositoryMock) ReserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserve.afterReserveCounter)
}

// ReserveBeforeCounter returns a count of RepositoryMock.Reserve invocations
func (mmReserve *RepositoryMock) ReserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserve.beforeReserveCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Reserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserve *mRepositoryMockReserve) Calls() []*RepositoryMockReserveParams {
	mmReserve.mutex.RLock()

	argCopy := make([]*RepositoryMockReserveParams, len(mmReserve.callArgs))
	copy(argCopy, mmReserve.callArgs)

	mmReserve.mutex.RUnlock()

	return argCopy
}

// MinimockReserveDone returns true if the count of the Reserve invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockReserveDone() bool {
	if m.ReserveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveMock.invocationsDone()
}

// MinimockReserveInspect logs each unmet expectation
func (m *RepositoryMock) MinimockReserveInspect() {
	for _, e := range m.ReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.Reserve at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReserveCounter := mm_atomic.LoadUint64(&m.afterReserveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveMock.defaultExpectation != nil && afterReserveCounter < 1 {
		if m.ReserveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.Reserve at\n%s", m.ReserveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.Reserve at\n%s with params: %#v", m.ReserveMock.defaultExpectation.expectationOrigins.origin, *m.ReserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserve != nil && afterReserveCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.Reserve at\n%s", m.funcReserveOrigin)
	}

	if !m.ReserveMock.invocationsDone() && afterReserveCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.Reserve at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveMock.expectedInvocations), m.ReserveMock.expectedInvocationsOrigin, afterReserveCounter)
	}
}

type mRepositoryMockReserveRemove struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockReserveRemoveExpectation
	expectations       []*RepositoryMockReserveRemoveExpectation

	callArgs []*RepositoryMockReserveRemoveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockReserveRemoveExpectation specifies expectation struct of the Repository.ReserveRemove
type RepositoryMockReserveRemoveExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockReserveRemoveParams
	paramPtrs          *RepositoryMockReserveRemoveParamPtrs
	expectationOrigins RepositoryMockReserveRemoveExpectationOrigins
	results            *RepositoryMockReserveRemoveResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockReserveRemoveParams contains parameters of the Repository.ReserveRemove
type RepositoryMockReserveRemoveParams struct {
	ctx   context.Context
	sku   uint32
	count uint16
}

// RepositoryMockReserveRemoveParamPtrs contains pointers to parameters of the Repository.ReserveRemove
type RepositoryMockReserveRemoveParamPtrs struct {
	ctx   *context.Context
	sku   *uint32
	count *uint16
}

// RepositoryMockReserveRemoveResults contains results of the Repository.ReserveRemove
type RepositoryMockReserveRemoveResults struct {
	err error
}

// RepositoryMockReserveRemoveOrigins contains origins of expectations of the Repository.ReserveRemove
type RepositoryMockReserveRemoveExpectationOrigins struct {
	origin      string
	originCtx   string
	originSku   string
	originCount string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserveRemove *mRepositoryMockReserveRemove) Optional() *mRepositoryMockReserveRemove {
	mmReserveRemove.optional = true
	return mmReserveRemove
}

// Expect sets up expected params for Repository.ReserveRemove
func (mmReserveRemove *mRepositoryMockReserveRemove) Expect(ctx context.Context, sku uint32, count uint16) *mRepositoryMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("RepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &RepositoryMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.paramPtrs != nil {
		mmReserveRemove.mock.t.Fatalf("RepositoryMock.ReserveRemove mock is already set by ExpectParams functions")
	}

	mmReserveRemove.defaultExpectation.params = &RepositoryMockReserveRemoveParams{ctx, sku, count}
	mmReserveRemove.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReserveRemove.expectations {
		if minimock.Equal(e.params, mmReserveRemove.defaultExpectation.params) {
			mmReserveRemove.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveRemove.defaultExpectation.params)
		}
	}

	return mmReserveRemove
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ReserveRemove
func (mmReserveRemove *mRepositoryMockReserveRemove) ExpectCtxParam1(ctx context.Context) *mRepositoryMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("RepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &RepositoryMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.params != nil {
		mmReserveRemove.mock.t.Fatalf("RepositoryMock.ReserveRemove mock is already set by Expect")
	}

	if mmReserveRemove.defaultExpectation.paramPtrs == nil {
		mmReserveRemove.defaultExpectation.paramPtrs = &RepositoryMockReserveRemoveParamPtrs{}
	}
	mmReserveRemove.defaultExpectation.paramPtrs.ctx = &ctx
	mmReserveRemove.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReserveRemove
}

// ExpectSkuParam2 sets up expected param sku for Repository.ReserveRemove
func (mmReserveRemove *mRepositoryMockReserveRemove) ExpectSkuParam2(sku uint32) *mRepositoryMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("RepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &RepositoryMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.params != nil {
		mmReserveRemove.mock.t.Fatalf("RepositoryMock.ReserveRemove mock is already set by Expect")
	}

	if mmReserveRemove.defaultExpectation.paramPtrs == nil {
		mmReserveRemove.defaultExpectation.paramPtrs = &RepositoryMockReserveRemoveParamPtrs{}
	}
	mmReserveRemove.defaultExpectation.paramPtrs.sku = &sku
	mmReserveRemove.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmReserveRemove
}

// ExpectCountParam3 sets up expected param count for Repository.ReserveRemove
func (mmReserveRemove *mRepositoryMockReserveRemove) ExpectCountParam3(count uint16) *mRepositoryMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("RepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &RepositoryMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.params != nil {
		mmReserveRemove.mock.t.Fatalf("RepositoryMock.ReserveRemove mock is already set by Expect")
	}

	if mmReserveRemove.defaultExpectation.paramPtrs == nil {
		mmReserveRemove.defaultExpectation.paramPtrs = &RepositoryMockReserveRemoveParamPtrs{}
	}
	mmReserveRemove.defaultExpectation.paramPtrs.count = &count
	mmReserveRemove.defaultExpectation.expectationOrigins.originCount = minimock.CallerInfo(1)

	return mmReserveRemove
}

// Inspect accepts an inspector function that has same arguments as the Repository.ReserveRemove
func (mmReserveRemove *mRepositoryMockReserveRemove) Inspect(f func(ctx context.Context, sku uint32, count uint16)) *mRepositoryMockReserveRemove {
	if mmReserveRemove.mock.inspectFuncReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ReserveRemove")
	}

	mmReserveRemove.mock.inspectFuncReserveRemove = f

	return mmReserveRemove
}

// Return sets up results that will be returned by Repository.ReserveRemove
func (mmReserveRemove *mRepositoryMockReserveRemove) Return(err error) *RepositoryMock {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("RepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &RepositoryMockReserveRemoveExpectation{mock: mmReserveRemove.mock}
	}
	mmReserveRemove.defaultExpectation.results = &RepositoryMockReserveRemoveResults{err}
	mmReserveRemove.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReserveRemove.mock
}

// Set uses given function f to mock the Repository.ReserveRemove method
func (mmReserveRemove *mRepositoryMockReserveRemove) Set(f func(ctx context.Context, sku uint32, count uint16) (err error)) *RepositoryMock {
	if mmReserveRemove.defaultExpectation != nil {
		mmReserveRemove.mock.t.Fatalf("Default expectation is already set for the Repository.ReserveRemove method")
	}

	if len(mmReserveRemove.expectations) > 0 {
		mmReserveRemove.mock.t.Fatalf("Some expectations are already set for the Repository.ReserveRemove method")
	}

	mmReserveRemove.mock.funcReserveRemove = f
	mmReserveRemove.mock.funcReserveRemoveOrigin = minimock.CallerInfo(1)
	return mmReserveRemove.mock
}

// When sets expectation for the Repository.ReserveRemove which will trigger the result defined by the following
// Then helper
func (mmReserveRemove *mRepositoryMockReserveRemove) When(ctx context.Context, sku uint32, count uint16) *RepositoryMockReserveRemoveExpectation {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("RepositoryMock.ReserveRemove mock is already set by Set")
	}

	expectation := &RepositoryMockReserveRemoveExpectation{
		mock:               mmReserveRemove.mock,
		params:             &RepositoryMockReserveRemoveParams{ctx, sku, count},
		expectationOrigins: RepositoryMockReserveRemoveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReserveRemove.expectations = append(mmReserveRemove.expectations, expectation)
	return expectation
}

// Then sets up Repository.ReserveRemove return parameters for the expectation previously defined by the When method
func (e *RepositoryMockReserveRemoveExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockReserveRemoveResults{err}
	return e.mock
}

// Times sets number of times Repository.ReserveRemove should be invoked
func (mmReserveRemove *mRepositoryMockReserveRemove) Times(n uint64) *mRepositoryMockReserveRemove {
	if n == 0 {
		mmReserveRemove.mock.t.Fatalf("Times of RepositoryMock.ReserveRemove mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserveRemove.expectedInvocations, n)
	mmReserveRemove.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReserveRemove
}

func (mmReserveRemove *mRepositoryMockReserveRemove) invocationsDone() bool {
	if len(mmReserveRemove.expectations) == 0 && mmReserveRemove.defaultExpectation == nil && mmReserveRemove.mock.funcReserveRemove == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserveRemove.mock.afterReserveRemoveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserveRemove.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReserveRemove implements mm_stock.Repository
func (mmReserveRemove *RepositoryMock) ReserveRemove(ctx context.Context, sku uint32, count uint16) (err error) {
	mm_atomic.AddUint64(&mmReserveRemove.beforeReserveRemoveCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveRemove.afterReserveRemoveCounter, 1)

	mmReserveRemove.t.Helper()

	if mmReserveRemove.inspectFuncReserveRemove != nil {
		mmReserveRemove.inspectFuncReserveRemove(ctx, sku, count)
	}

	mm_params := RepositoryMockReserveRemoveParams{ctx, sku, count}

	// Record call args
	mmReserveRemove.ReserveRemoveMock.mutex.Lock()
	mmReserveRemove.ReserveRemoveMock.callArgs = append(mmReserveRemove.ReserveRemoveMock.callArgs, &mm_params)
	mmReserveRemove.ReserveRemoveMock.mutex.Unlock()

	for _, e := range mmReserveRemove.ReserveRemoveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveRemove.ReserveRemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveRemove.ReserveRemoveMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveRemove.ReserveRemoveMock.defaultExpectation.params
		mm_want_ptrs := mmReserveRemove.ReserveRemoveMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockReserveRemoveParams{ctx, sku, count}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserveRemove.t.Errorf("RepositoryMock.ReserveRemove got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveRemove.ReserveRemoveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmReserveRemove.t.Errorf("RepositoryMock.ReserveRemove got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveRemove.ReserveRemoveMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

			if mm_want_ptrs.count != nil && !minimock.Equal(*mm_want_ptrs.count, mm_got.count) {
				mmReserveRemove.t.Errorf("RepositoryMock.ReserveRemove got unexpected parameter count, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveRemove.ReserveRemoveMock.defaultExpectation.expectationOrigins.originCount, *mm_want_ptrs.count, mm_got.count, minimock.Diff(*mm_want_ptrs.count, mm_got.count))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveRemove.t.Errorf("RepositoryMock.ReserveRemove got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReserveRemove.ReserveRemoveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveRemove.ReserveRemoveMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveRemove.t.Fatal("No results are set for the RepositoryMock.ReserveRemove")
		}
		return (*mm_results).err
	}
	if mmReserveRemove.funcReserveRemove != nil {
		return mmReserveRemove.funcReserveRemove(ctx, sku, count)
	}
	mmReserveRemove.t.Fatalf("Unexpected call to RepositoryMock.ReserveRemove. %v %v %v", ctx, sku, count)
	return
}

// ReserveRemoveAfterCounter returns a count of finished RepositoryMock.ReserveRemove invocations
func (mmReserveRemove *RepositoryMock) ReserveRemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveRemove.afterReserveRemoveCounter)
}

// ReserveRemoveBeforeCounter returns a count of RepositoryMock.ReserveRemove invocations
func (mmReserveRemove *RepositoryMock) ReserveRemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveRemove.beforeReserveRemoveCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ReserveRemove.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveRemove *mRepositoryMockReserveRemove) Calls() []*RepositoryMockReserveRemoveParams {
	mmReserveRemove.mutex.RLock()

	argCopy := make([]*RepositoryMockReserveRemoveParams, len(mmReserveRemove.callArgs))
	copy(argCopy, mmReserveRemove.callArgs)

	mmReserveRemove.mutex.RUnlock()

	return argCopy
}

// MinimockReserveRemoveDone returns true if the count of the ReserveRemove invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockReserveRemoveDone() bool {
	if m.ReserveRemoveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveRemoveMock.invocationsDone()
}

// MinimockReserveRemoveInspect logs each unmet expectation
func (m *RepositoryMock) MinimockReserveRemoveInspect() {
	for _, e := range m.ReserveRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ReserveRemove at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReserveRemoveCounter := mm_atomic.LoadUint64(&m.afterReserveRemoveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveRemoveMock.defaultExpectation != nil && afterReserveRemoveCounter < 1 {
		if m.ReserveRemoveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ReserveRemove at\n%s", m.ReserveRemoveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ReserveRemove at\n%s with params: %#v", m.ReserveRemoveMock.defaultExpectation.expectationOrigins.origin, *m.ReserveRemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveRemove != nil && afterReserveRemoveCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ReserveRemove at\n%s", m.funcReserveRemoveOrigin)
	}

	if !m.ReserveRemoveMock.invocationsDone() && afterReserveRemoveCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ReserveRemove at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveRemoveMock.expectedInvocations), m.ReserveRemoveMock.expectedInvocationsOrigin, afterReserveRemoveCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetBySKUInspect()

			m.MinimockReleaseInspect()

			m.MinimockReserveInspect()

			m.MinimockReserveRemoveInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetBySKUDone() &&
		m.MinimockReleaseDone() &&
		m.MinimockReserveDone() &&
		m.MinimockReserveRemoveDone()
}
