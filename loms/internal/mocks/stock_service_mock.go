// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mocks

//go:generate minimock -i gitlab.ozon.dev/kanat_9999/homework/loms/internal/service/stock.StockRepository -o stock_service_mock.go -n StockRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StockRepositoryMock implements mm_service.StockRepository
type StockRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetBySKU          func(ctx context.Context, sku uint32) (u1 uint64, err error)
	funcGetBySKUOrigin    string
	inspectFuncGetBySKU   func(ctx context.Context, sku uint32)
	afterGetBySKUCounter  uint64
	beforeGetBySKUCounter uint64
	GetBySKUMock          mStockRepositoryMockGetBySKU

	funcRelease          func(ctx context.Context, sku uint32, count uint16) (err error)
	funcReleaseOrigin    string
	inspectFuncRelease   func(ctx context.Context, sku uint32, count uint16)
	afterReleaseCounter  uint64
	beforeReleaseCounter uint64
	ReleaseMock          mStockRepositoryMockRelease

	funcReserve          func(ctx context.Context, sku uint32, count uint16) (err error)
	funcReserveOrigin    string
	inspectFuncReserve   func(ctx context.Context, sku uint32, count uint16)
	afterReserveCounter  uint64
	beforeReserveCounter uint64
	ReserveMock          mStockRepositoryMockReserve

	funcReserveRemove          func(ctx context.Context, sku uint32, count uint16) (err error)
	funcReserveRemoveOrigin    string
	inspectFuncReserveRemove   func(ctx context.Context, sku uint32, count uint16)
	afterReserveRemoveCounter  uint64
	beforeReserveRemoveCounter uint64
	ReserveRemoveMock          mStockRepositoryMockReserveRemove
}

// NewStockRepositoryMock returns a mock for mm_service.StockRepository
func NewStockRepositoryMock(t minimock.Tester) *StockRepositoryMock {
	m := &StockRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetBySKUMock = mStockRepositoryMockGetBySKU{mock: m}
	m.GetBySKUMock.callArgs = []*StockRepositoryMockGetBySKUParams{}

	m.ReleaseMock = mStockRepositoryMockRelease{mock: m}
	m.ReleaseMock.callArgs = []*StockRepositoryMockReleaseParams{}

	m.ReserveMock = mStockRepositoryMockReserve{mock: m}
	m.ReserveMock.callArgs = []*StockRepositoryMockReserveParams{}

	m.ReserveRemoveMock = mStockRepositoryMockReserveRemove{mock: m}
	m.ReserveRemoveMock.callArgs = []*StockRepositoryMockReserveRemoveParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStockRepositoryMockGetBySKU struct {
	optional           bool
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockGetBySKUExpectation
	expectations       []*StockRepositoryMockGetBySKUExpectation

	callArgs []*StockRepositoryMockGetBySKUParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockRepositoryMockGetBySKUExpectation specifies expectation struct of the StockRepository.GetBySKU
type StockRepositoryMockGetBySKUExpectation struct {
	mock               *StockRepositoryMock
	params             *StockRepositoryMockGetBySKUParams
	paramPtrs          *StockRepositoryMockGetBySKUParamPtrs
	expectationOrigins StockRepositoryMockGetBySKUExpectationOrigins
	results            *StockRepositoryMockGetBySKUResults
	returnOrigin       string
	Counter            uint64
}

// StockRepositoryMockGetBySKUParams contains parameters of the StockRepository.GetBySKU
type StockRepositoryMockGetBySKUParams struct {
	ctx context.Context
	sku uint32
}

// StockRepositoryMockGetBySKUParamPtrs contains pointers to parameters of the StockRepository.GetBySKU
type StockRepositoryMockGetBySKUParamPtrs struct {
	ctx *context.Context
	sku *uint32
}

// StockRepositoryMockGetBySKUResults contains results of the StockRepository.GetBySKU
type StockRepositoryMockGetBySKUResults struct {
	u1  uint64
	err error
}

// StockRepositoryMockGetBySKUOrigins contains origins of expectations of the StockRepository.GetBySKU
type StockRepositoryMockGetBySKUExpectationOrigins struct {
	origin    string
	originCtx string
	originSku string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBySKU *mStockRepositoryMockGetBySKU) Optional() *mStockRepositoryMockGetBySKU {
	mmGetBySKU.optional = true
	return mmGetBySKU
}

// Expect sets up expected params for StockRepository.GetBySKU
func (mmGetBySKU *mStockRepositoryMockGetBySKU) Expect(ctx context.Context, sku uint32) *mStockRepositoryMockGetBySKU {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("StockRepositoryMock.GetBySKU mock is already set by Set")
	}

	if mmGetBySKU.defaultExpectation == nil {
		mmGetBySKU.defaultExpectation = &StockRepositoryMockGetBySKUExpectation{}
	}

	if mmGetBySKU.defaultExpectation.paramPtrs != nil {
		mmGetBySKU.mock.t.Fatalf("StockRepositoryMock.GetBySKU mock is already set by ExpectParams functions")
	}

	mmGetBySKU.defaultExpectation.params = &StockRepositoryMockGetBySKUParams{ctx, sku}
	mmGetBySKU.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetBySKU.expectations {
		if minimock.Equal(e.params, mmGetBySKU.defaultExpectation.params) {
			mmGetBySKU.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBySKU.defaultExpectation.params)
		}
	}

	return mmGetBySKU
}

// ExpectCtxParam1 sets up expected param ctx for StockRepository.GetBySKU
func (mmGetBySKU *mStockRepositoryMockGetBySKU) ExpectCtxParam1(ctx context.Context) *mStockRepositoryMockGetBySKU {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("StockRepositoryMock.GetBySKU mock is already set by Set")
	}

	if mmGetBySKU.defaultExpectation == nil {
		mmGetBySKU.defaultExpectation = &StockRepositoryMockGetBySKUExpectation{}
	}

	if mmGetBySKU.defaultExpectation.params != nil {
		mmGetBySKU.mock.t.Fatalf("StockRepositoryMock.GetBySKU mock is already set by Expect")
	}

	if mmGetBySKU.defaultExpectation.paramPtrs == nil {
		mmGetBySKU.defaultExpectation.paramPtrs = &StockRepositoryMockGetBySKUParamPtrs{}
	}
	mmGetBySKU.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetBySKU.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetBySKU
}

// ExpectSkuParam2 sets up expected param sku for StockRepository.GetBySKU
func (mmGetBySKU *mStockRepositoryMockGetBySKU) ExpectSkuParam2(sku uint32) *mStockRepositoryMockGetBySKU {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("StockRepositoryMock.GetBySKU mock is already set by Set")
	}

	if mmGetBySKU.defaultExpectation == nil {
		mmGetBySKU.defaultExpectation = &StockRepositoryMockGetBySKUExpectation{}
	}

	if mmGetBySKU.defaultExpectation.params != nil {
		mmGetBySKU.mock.t.Fatalf("StockRepositoryMock.GetBySKU mock is already set by Expect")
	}

	if mmGetBySKU.defaultExpectation.paramPtrs == nil {
		mmGetBySKU.defaultExpectation.paramPtrs = &StockRepositoryMockGetBySKUParamPtrs{}
	}
	mmGetBySKU.defaultExpectation.paramPtrs.sku = &sku
	mmGetBySKU.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmGetBySKU
}

// Inspect accepts an inspector function that has same arguments as the StockRepository.GetBySKU
func (mmGetBySKU *mStockRepositoryMockGetBySKU) Inspect(f func(ctx context.Context, sku uint32)) *mStockRepositoryMockGetBySKU {
	if mmGetBySKU.mock.inspectFuncGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.GetBySKU")
	}

	mmGetBySKU.mock.inspectFuncGetBySKU = f

	return mmGetBySKU
}

// Return sets up results that will be returned by StockRepository.GetBySKU
func (mmGetBySKU *mStockRepositoryMockGetBySKU) Return(u1 uint64, err error) *StockRepositoryMock {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("StockRepositoryMock.GetBySKU mock is already set by Set")
	}

	if mmGetBySKU.defaultExpectation == nil {
		mmGetBySKU.defaultExpectation = &StockRepositoryMockGetBySKUExpectation{mock: mmGetBySKU.mock}
	}
	mmGetBySKU.defaultExpectation.results = &StockRepositoryMockGetBySKUResults{u1, err}
	mmGetBySKU.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetBySKU.mock
}

// Set uses given function f to mock the StockRepository.GetBySKU method
func (mmGetBySKU *mStockRepositoryMockGetBySKU) Set(f func(ctx context.Context, sku uint32) (u1 uint64, err error)) *StockRepositoryMock {
	if mmGetBySKU.defaultExpectation != nil {
		mmGetBySKU.mock.t.Fatalf("Default expectation is already set for the StockRepository.GetBySKU method")
	}

	if len(mmGetBySKU.expectations) > 0 {
		mmGetBySKU.mock.t.Fatalf("Some expectations are already set for the StockRepository.GetBySKU method")
	}

	mmGetBySKU.mock.funcGetBySKU = f
	mmGetBySKU.mock.funcGetBySKUOrigin = minimock.CallerInfo(1)
	return mmGetBySKU.mock
}

// When sets expectation for the StockRepository.GetBySKU which will trigger the result defined by the following
// Then helper
func (mmGetBySKU *mStockRepositoryMockGetBySKU) When(ctx context.Context, sku uint32) *StockRepositoryMockGetBySKUExpectation {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("StockRepositoryMock.GetBySKU mock is already set by Set")
	}

	expectation := &StockRepositoryMockGetBySKUExpectation{
		mock:               mmGetBySKU.mock,
		params:             &StockRepositoryMockGetBySKUParams{ctx, sku},
		expectationOrigins: StockRepositoryMockGetBySKUExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetBySKU.expectations = append(mmGetBySKU.expectations, expectation)
	return expectation
}

// Then sets up StockRepository.GetBySKU return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockGetBySKUExpectation) Then(u1 uint64, err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockGetBySKUResults{u1, err}
	return e.mock
}

// Times sets number of times StockRepository.GetBySKU should be invoked
func (mmGetBySKU *mStockRepositoryMockGetBySKU) Times(n uint64) *mStockRepositoryMockGetBySKU {
	if n == 0 {
		mmGetBySKU.mock.t.Fatalf("Times of StockRepositoryMock.GetBySKU mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetBySKU.expectedInvocations, n)
	mmGetBySKU.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetBySKU
}

func (mmGetBySKU *mStockRepositoryMockGetBySKU) invocationsDone() bool {
	if len(mmGetBySKU.expectations) == 0 && mmGetBySKU.defaultExpectation == nil && mmGetBySKU.mock.funcGetBySKU == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetBySKU.mock.afterGetBySKUCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetBySKU.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetBySKU implements mm_service.StockRepository
func (mmGetBySKU *StockRepositoryMock) GetBySKU(ctx context.Context, sku uint32) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmGetBySKU.beforeGetBySKUCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBySKU.afterGetBySKUCounter, 1)

	mmGetBySKU.t.Helper()

	if mmGetBySKU.inspectFuncGetBySKU != nil {
		mmGetBySKU.inspectFuncGetBySKU(ctx, sku)
	}

	mm_params := StockRepositoryMockGetBySKUParams{ctx, sku}

	// Record call args
	mmGetBySKU.GetBySKUMock.mutex.Lock()
	mmGetBySKU.GetBySKUMock.callArgs = append(mmGetBySKU.GetBySKUMock.callArgs, &mm_params)
	mmGetBySKU.GetBySKUMock.mutex.Unlock()

	for _, e := range mmGetBySKU.GetBySKUMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetBySKU.GetBySKUMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBySKU.GetBySKUMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBySKU.GetBySKUMock.defaultExpectation.params
		mm_want_ptrs := mmGetBySKU.GetBySKUMock.defaultExpectation.paramPtrs

		mm_got := StockRepositoryMockGetBySKUParams{ctx, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetBySKU.t.Errorf("StockRepositoryMock.GetBySKU got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBySKU.GetBySKUMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmGetBySKU.t.Errorf("StockRepositoryMock.GetBySKU got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBySKU.GetBySKUMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBySKU.t.Errorf("StockRepositoryMock.GetBySKU got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetBySKU.GetBySKUMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBySKU.GetBySKUMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBySKU.t.Fatal("No results are set for the StockRepositoryMock.GetBySKU")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetBySKU.funcGetBySKU != nil {
		return mmGetBySKU.funcGetBySKU(ctx, sku)
	}
	mmGetBySKU.t.Fatalf("Unexpected call to StockRepositoryMock.GetBySKU. %v %v", ctx, sku)
	return
}

// GetBySKUAfterCounter returns a count of finished StockRepositoryMock.GetBySKU invocations
func (mmGetBySKU *StockRepositoryMock) GetBySKUAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBySKU.afterGetBySKUCounter)
}

// GetBySKUBeforeCounter returns a count of StockRepositoryMock.GetBySKU invocations
func (mmGetBySKU *StockRepositoryMock) GetBySKUBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBySKU.beforeGetBySKUCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.GetBySKU.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBySKU *mStockRepositoryMockGetBySKU) Calls() []*StockRepositoryMockGetBySKUParams {
	mmGetBySKU.mutex.RLock()

	argCopy := make([]*StockRepositoryMockGetBySKUParams, len(mmGetBySKU.callArgs))
	copy(argCopy, mmGetBySKU.callArgs)

	mmGetBySKU.mutex.RUnlock()

	return argCopy
}

// MinimockGetBySKUDone returns true if the count of the GetBySKU invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockGetBySKUDone() bool {
	if m.GetBySKUMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetBySKUMock.invocationsDone()
}

// MinimockGetBySKUInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockGetBySKUInspect() {
	for _, e := range m.GetBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.GetBySKU at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetBySKUCounter := mm_atomic.LoadUint64(&m.afterGetBySKUCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetBySKUMock.defaultExpectation != nil && afterGetBySKUCounter < 1 {
		if m.GetBySKUMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockRepositoryMock.GetBySKU at\n%s", m.GetBySKUMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.GetBySKU at\n%s with params: %#v", m.GetBySKUMock.defaultExpectation.expectationOrigins.origin, *m.GetBySKUMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBySKU != nil && afterGetBySKUCounter < 1 {
		m.t.Errorf("Expected call to StockRepositoryMock.GetBySKU at\n%s", m.funcGetBySKUOrigin)
	}

	if !m.GetBySKUMock.invocationsDone() && afterGetBySKUCounter > 0 {
		m.t.Errorf("Expected %d calls to StockRepositoryMock.GetBySKU at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetBySKUMock.expectedInvocations), m.GetBySKUMock.expectedInvocationsOrigin, afterGetBySKUCounter)
	}
}

type mStockRepositoryMockRelease struct {
	optional           bool
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockReleaseExpectation
	expectations       []*StockRepositoryMockReleaseExpectation

	callArgs []*StockRepositoryMockReleaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockRepositoryMockReleaseExpectation specifies expectation struct of the StockRepository.Release
type StockRepositoryMockReleaseExpectation struct {
	mock               *StockRepositoryMock
	params             *StockRepositoryMockReleaseParams
	paramPtrs          *StockRepositoryMockReleaseParamPtrs
	expectationOrigins StockRepositoryMockReleaseExpectationOrigins
	results            *StockRepositoryMockReleaseResults
	returnOrigin       string
	Counter            uint64
}

// StockRepositoryMockReleaseParams contains parameters of the StockRepository.Release
type StockRepositoryMockReleaseParams struct {
	ctx   context.Context
	sku   uint32
	count uint16
}

// StockRepositoryMockReleaseParamPtrs contains pointers to parameters of the StockRepository.Release
type StockRepositoryMockReleaseParamPtrs struct {
	ctx   *context.Context
	sku   *uint32
	count *uint16
}

// StockRepositoryMockReleaseResults contains results of the StockRepository.Release
type StockRepositoryMockReleaseResults struct {
	err error
}

// StockRepositoryMockReleaseOrigins contains origins of expectations of the StockRepository.Release
type StockRepositoryMockReleaseExpectationOrigins struct {
	origin      string
	originCtx   string
	originSku   string
	originCount string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRelease *mStockRepositoryMockRelease) Optional() *mStockRepositoryMockRelease {
	mmRelease.optional = true
	return mmRelease
}

// Expect sets up expected params for StockRepository.Release
func (mmRelease *mStockRepositoryMockRelease) Expect(ctx context.Context, sku uint32, count uint16) *mStockRepositoryMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("StockRepositoryMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &StockRepositoryMockReleaseExpectation{}
	}

	if mmRelease.defaultExpectation.paramPtrs != nil {
		mmRelease.mock.t.Fatalf("StockRepositoryMock.Release mock is already set by ExpectParams functions")
	}

	mmRelease.defaultExpectation.params = &StockRepositoryMockReleaseParams{ctx, sku, count}
	mmRelease.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRelease.expectations {
		if minimock.Equal(e.params, mmRelease.defaultExpectation.params) {
			mmRelease.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRelease.defaultExpectation.params)
		}
	}

	return mmRelease
}

// ExpectCtxParam1 sets up expected param ctx for StockRepository.Release
func (mmRelease *mStockRepositoryMockRelease) ExpectCtxParam1(ctx context.Context) *mStockRepositoryMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("StockRepositoryMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &StockRepositoryMockReleaseExpectation{}
	}

	if mmRelease.defaultExpectation.params != nil {
		mmRelease.mock.t.Fatalf("StockRepositoryMock.Release mock is already set by Expect")
	}

	if mmRelease.defaultExpectation.paramPtrs == nil {
		mmRelease.defaultExpectation.paramPtrs = &StockRepositoryMockReleaseParamPtrs{}
	}
	mmRelease.defaultExpectation.paramPtrs.ctx = &ctx
	mmRelease.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRelease
}

// ExpectSkuParam2 sets up expected param sku for StockRepository.Release
func (mmRelease *mStockRepositoryMockRelease) ExpectSkuParam2(sku uint32) *mStockRepositoryMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("StockRepositoryMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &StockRepositoryMockReleaseExpectation{}
	}

	if mmRelease.defaultExpectation.params != nil {
		mmRelease.mock.t.Fatalf("StockRepositoryMock.Release mock is already set by Expect")
	}

	if mmRelease.defaultExpectation.paramPtrs == nil {
		mmRelease.defaultExpectation.paramPtrs = &StockRepositoryMockReleaseParamPtrs{}
	}
	mmRelease.defaultExpectation.paramPtrs.sku = &sku
	mmRelease.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmRelease
}

// ExpectCountParam3 sets up expected param count for StockRepository.Release
func (mmRelease *mStockRepositoryMockRelease) ExpectCountParam3(count uint16) *mStockRepositoryMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("StockRepositoryMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &StockRepositoryMockReleaseExpectation{}
	}

	if mmRelease.defaultExpectation.params != nil {
		mmRelease.mock.t.Fatalf("StockRepositoryMock.Release mock is already set by Expect")
	}

	if mmRelease.defaultExpectation.paramPtrs == nil {
		mmRelease.defaultExpectation.paramPtrs = &StockRepositoryMockReleaseParamPtrs{}
	}
	mmRelease.defaultExpectation.paramPtrs.count = &count
	mmRelease.defaultExpectation.expectationOrigins.originCount = minimock.CallerInfo(1)

	return mmRelease
}

// Inspect accepts an inspector function that has same arguments as the StockRepository.Release
func (mmRelease *mStockRepositoryMockRelease) Inspect(f func(ctx context.Context, sku uint32, count uint16)) *mStockRepositoryMockRelease {
	if mmRelease.mock.inspectFuncRelease != nil {
		mmRelease.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.Release")
	}

	mmRelease.mock.inspectFuncRelease = f

	return mmRelease
}

// Return sets up results that will be returned by StockRepository.Release
func (mmRelease *mStockRepositoryMockRelease) Return(err error) *StockRepositoryMock {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("StockRepositoryMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &StockRepositoryMockReleaseExpectation{mock: mmRelease.mock}
	}
	mmRelease.defaultExpectation.results = &StockRepositoryMockReleaseResults{err}
	mmRelease.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRelease.mock
}

// Set uses given function f to mock the StockRepository.Release method
func (mmRelease *mStockRepositoryMockRelease) Set(f func(ctx context.Context, sku uint32, count uint16) (err error)) *StockRepositoryMock {
	if mmRelease.defaultExpectation != nil {
		mmRelease.mock.t.Fatalf("Default expectation is already set for the StockRepository.Release method")
	}

	if len(mmRelease.expectations) > 0 {
		mmRelease.mock.t.Fatalf("Some expectations are already set for the StockRepository.Release method")
	}

	mmRelease.mock.funcRelease = f
	mmRelease.mock.funcReleaseOrigin = minimock.CallerInfo(1)
	return mmRelease.mock
}

// When sets expectation for the StockRepository.Release which will trigger the result defined by the following
// Then helper
func (mmRelease *mStockRepositoryMockRelease) When(ctx context.Context, sku uint32, count uint16) *StockRepositoryMockReleaseExpectation {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("StockRepositoryMock.Release mock is already set by Set")
	}

	expectation := &StockRepositoryMockReleaseExpectation{
		mock:               mmRelease.mock,
		params:             &StockRepositoryMockReleaseParams{ctx, sku, count},
		expectationOrigins: StockRepositoryMockReleaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRelease.expectations = append(mmRelease.expectations, expectation)
	return expectation
}

// Then sets up StockRepository.Release return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockReleaseExpectation) Then(err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockReleaseResults{err}
	return e.mock
}

// Times sets number of times StockRepository.Release should be invoked
func (mmRelease *mStockRepositoryMockRelease) Times(n uint64) *mStockRepositoryMockRelease {
	if n == 0 {
		mmRelease.mock.t.Fatalf("Times of StockRepositoryMock.Release mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRelease.expectedInvocations, n)
	mmRelease.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRelease
}

func (mmRelease *mStockRepositoryMockRelease) invocationsDone() bool {
	if len(mmRelease.expectations) == 0 && mmRelease.defaultExpectation == nil && mmRelease.mock.funcRelease == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRelease.mock.afterReleaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRelease.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Release implements mm_service.StockRepository
func (mmRelease *StockRepositoryMock) Release(ctx context.Context, sku uint32, count uint16) (err error) {
	mm_atomic.AddUint64(&mmRelease.beforeReleaseCounter, 1)
	defer mm_atomic.AddUint64(&mmRelease.afterReleaseCounter, 1)

	mmRelease.t.Helper()

	if mmRelease.inspectFuncRelease != nil {
		mmRelease.inspectFuncRelease(ctx, sku, count)
	}

	mm_params := StockRepositoryMockReleaseParams{ctx, sku, count}

	// Record call args
	mmRelease.ReleaseMock.mutex.Lock()
	mmRelease.ReleaseMock.callArgs = append(mmRelease.ReleaseMock.callArgs, &mm_params)
	mmRelease.ReleaseMock.mutex.Unlock()

	for _, e := range mmRelease.ReleaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRelease.ReleaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRelease.ReleaseMock.defaultExpectation.Counter, 1)
		mm_want := mmRelease.ReleaseMock.defaultExpectation.params
		mm_want_ptrs := mmRelease.ReleaseMock.defaultExpectation.paramPtrs

		mm_got := StockRepositoryMockReleaseParams{ctx, sku, count}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRelease.t.Errorf("StockRepositoryMock.Release got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRelease.ReleaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmRelease.t.Errorf("StockRepositoryMock.Release got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRelease.ReleaseMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

			if mm_want_ptrs.count != nil && !minimock.Equal(*mm_want_ptrs.count, mm_got.count) {
				mmRelease.t.Errorf("StockRepositoryMock.Release got unexpected parameter count, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRelease.ReleaseMock.defaultExpectation.expectationOrigins.originCount, *mm_want_ptrs.count, mm_got.count, minimock.Diff(*mm_want_ptrs.count, mm_got.count))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRelease.t.Errorf("StockRepositoryMock.Release got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRelease.ReleaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRelease.ReleaseMock.defaultExpectation.results
		if mm_results == nil {
			mmRelease.t.Fatal("No results are set for the StockRepositoryMock.Release")
		}
		return (*mm_results).err
	}
	if mmRelease.funcRelease != nil {
		return mmRelease.funcRelease(ctx, sku, count)
	}
	mmRelease.t.Fatalf("Unexpected call to StockRepositoryMock.Release. %v %v %v", ctx, sku, count)
	return
}

// ReleaseAfterCounter returns a count of finished StockRepositoryMock.Release invocations
func (mmRelease *StockRepositoryMock) ReleaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRelease.afterReleaseCounter)
}

// ReleaseBeforeCounter returns a count of StockRepositoryMock.Release invocations
func (mmRelease *StockRepositoryMock) ReleaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRelease.beforeReleaseCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.Release.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRelease *mStockRepositoryMockRelease) Calls() []*StockRepositoryMockReleaseParams {
	mmRelease.mutex.RLock()

	argCopy := make([]*StockRepositoryMockReleaseParams, len(mmRelease.callArgs))
	copy(argCopy, mmRelease.callArgs)

	mmRelease.mutex.RUnlock()

	return argCopy
}

// MinimockReleaseDone returns true if the count of the Release invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockReleaseDone() bool {
	if m.ReleaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReleaseMock.invocationsDone()
}

// MinimockReleaseInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockReleaseInspect() {
	for _, e := range m.ReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.Release at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReleaseCounter := mm_atomic.LoadUint64(&m.afterReleaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReleaseMock.defaultExpectation != nil && afterReleaseCounter < 1 {
		if m.ReleaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockRepositoryMock.Release at\n%s", m.ReleaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.Release at\n%s with params: %#v", m.ReleaseMock.defaultExpectation.expectationOrigins.origin, *m.ReleaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRelease != nil && afterReleaseCounter < 1 {
		m.t.Errorf("Expected call to StockRepositoryMock.Release at\n%s", m.funcReleaseOrigin)
	}

	if !m.ReleaseMock.invocationsDone() && afterReleaseCounter > 0 {
		m.t.Errorf("Expected %d calls to StockRepositoryMock.Release at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReleaseMock.expectedInvocations), m.ReleaseMock.expectedInvocationsOrigin, afterReleaseCounter)
	}
}

type mStockRepositoryMockReserve struct {
	optional           bool
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockReserveExpectation
	expectations       []*StockRepositoryMockReserveExpectation

	callArgs []*StockRepositoryMockReserveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockRepositoryMockReserveExpectation specifies expectation struct of the StockRepository.Reserve
type StockRepositoryMockReserveExpectation struct {
	mock               *StockRepositoryMock
	params             *StockRepositoryMockReserveParams
	paramPtrs          *StockRepositoryMockReserveParamPtrs
	expectationOrigins StockRepositoryMockReserveExpectationOrigins
	results            *StockRepositoryMockReserveResults
	returnOrigin       string
	Counter            uint64
}

// StockRepositoryMockReserveParams contains parameters of the StockRepository.Reserve
type StockRepositoryMockReserveParams struct {
	ctx   context.Context
	sku   uint32
	count uint16
}

// StockRepositoryMockReserveParamPtrs contains pointers to parameters of the StockRepository.Reserve
type StockRepositoryMockReserveParamPtrs struct {
	ctx   *context.Context
	sku   *uint32
	count *uint16
}

// StockRepositoryMockReserveResults contains results of the StockRepository.Reserve
type StockRepositoryMockReserveResults struct {
	err error
}

// StockRepositoryMockReserveOrigins contains origins of expectations of the StockRepository.Reserve
type StockRepositoryMockReserveExpectationOrigins struct {
	origin      string
	originCtx   string
	originSku   string
	originCount string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserve *mStockRepositoryMockReserve) Optional() *mStockRepositoryMockReserve {
	mmReserve.optional = true
	return mmReserve
}

// Expect sets up expected params for StockRepository.Reserve
func (mmReserve *mStockRepositoryMockReserve) Expect(ctx context.Context, sku uint32, count uint16) *mStockRepositoryMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockRepositoryMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.paramPtrs != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by ExpectParams functions")
	}

	mmReserve.defaultExpectation.params = &StockRepositoryMockReserveParams{ctx, sku, count}
	mmReserve.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReserve.expectations {
		if minimock.Equal(e.params, mmReserve.defaultExpectation.params) {
			mmReserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserve.defaultExpectation.params)
		}
	}

	return mmReserve
}

// ExpectCtxParam1 sets up expected param ctx for StockRepository.Reserve
func (mmReserve *mStockRepositoryMockReserve) ExpectCtxParam1(ctx context.Context) *mStockRepositoryMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockRepositoryMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &StockRepositoryMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.ctx = &ctx
	mmReserve.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReserve
}

// ExpectSkuParam2 sets up expected param sku for StockRepository.Reserve
func (mmReserve *mStockRepositoryMockReserve) ExpectSkuParam2(sku uint32) *mStockRepositoryMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockRepositoryMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &StockRepositoryMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.sku = &sku
	mmReserve.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmReserve
}

// ExpectCountParam3 sets up expected param count for StockRepository.Reserve
func (mmReserve *mStockRepositoryMockReserve) ExpectCountParam3(count uint16) *mStockRepositoryMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockRepositoryMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &StockRepositoryMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.count = &count
	mmReserve.defaultExpectation.expectationOrigins.originCount = minimock.CallerInfo(1)

	return mmReserve
}

// Inspect accepts an inspector function that has same arguments as the StockRepository.Reserve
func (mmReserve *mStockRepositoryMockReserve) Inspect(f func(ctx context.Context, sku uint32, count uint16)) *mStockRepositoryMockReserve {
	if mmReserve.mock.inspectFuncReserve != nil {
		mmReserve.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.Reserve")
	}

	mmReserve.mock.inspectFuncReserve = f

	return mmReserve
}

// Return sets up results that will be returned by StockRepository.Reserve
func (mmReserve *mStockRepositoryMockReserve) Return(err error) *StockRepositoryMock {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockRepositoryMockReserveExpectation{mock: mmReserve.mock}
	}
	mmReserve.defaultExpectation.results = &StockRepositoryMockReserveResults{err}
	mmReserve.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReserve.mock
}

// Set uses given function f to mock the StockRepository.Reserve method
func (mmReserve *mStockRepositoryMockReserve) Set(f func(ctx context.Context, sku uint32, count uint16) (err error)) *StockRepositoryMock {
	if mmReserve.defaultExpectation != nil {
		mmReserve.mock.t.Fatalf("Default expectation is already set for the StockRepository.Reserve method")
	}

	if len(mmReserve.expectations) > 0 {
		mmReserve.mock.t.Fatalf("Some expectations are already set for the StockRepository.Reserve method")
	}

	mmReserve.mock.funcReserve = f
	mmReserve.mock.funcReserveOrigin = minimock.CallerInfo(1)
	return mmReserve.mock
}

// When sets expectation for the StockRepository.Reserve which will trigger the result defined by the following
// Then helper
func (mmReserve *mStockRepositoryMockReserve) When(ctx context.Context, sku uint32, count uint16) *StockRepositoryMockReserveExpectation {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockRepositoryMock.Reserve mock is already set by Set")
	}

	expectation := &StockRepositoryMockReserveExpectation{
		mock:               mmReserve.mock,
		params:             &StockRepositoryMockReserveParams{ctx, sku, count},
		expectationOrigins: StockRepositoryMockReserveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReserve.expectations = append(mmReserve.expectations, expectation)
	return expectation
}

// Then sets up StockRepository.Reserve return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockReserveExpectation) Then(err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockReserveResults{err}
	return e.mock
}

// Times sets number of times StockRepository.Reserve should be invoked
func (mmReserve *mStockRepositoryMockReserve) Times(n uint64) *mStockRepositoryMockReserve {
	if n == 0 {
		mmReserve.mock.t.Fatalf("Times of StockRepositoryMock.Reserve mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserve.expectedInvocations, n)
	mmReserve.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReserve
}

func (mmReserve *mStockRepositoryMockReserve) invocationsDone() bool {
	if len(mmReserve.expectations) == 0 && mmReserve.defaultExpectation == nil && mmReserve.mock.funcReserve == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserve.mock.afterReserveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserve.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Reserve implements mm_service.StockRepository
func (mmReserve *StockRepositoryMock) Reserve(ctx context.Context, sku uint32, count uint16) (err error) {
	mm_atomic.AddUint64(&mmReserve.beforeReserveCounter, 1)
	defer mm_atomic.AddUint64(&mmReserve.afterReserveCounter, 1)

	mmReserve.t.Helper()

	if mmReserve.inspectFuncReserve != nil {
		mmReserve.inspectFuncReserve(ctx, sku, count)
	}

	mm_params := StockRepositoryMockReserveParams{ctx, sku, count}

	// Record call args
	mmReserve.ReserveMock.mutex.Lock()
	mmReserve.ReserveMock.callArgs = append(mmReserve.ReserveMock.callArgs, &mm_params)
	mmReserve.ReserveMock.mutex.Unlock()

	for _, e := range mmReserve.ReserveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserve.ReserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserve.ReserveMock.defaultExpectation.Counter, 1)
		mm_want := mmReserve.ReserveMock.defaultExpectation.params
		mm_want_ptrs := mmReserve.ReserveMock.defaultExpectation.paramPtrs

		mm_got := StockRepositoryMockReserveParams{ctx, sku, count}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserve.t.Errorf("StockRepositoryMock.Reserve got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserve.ReserveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmReserve.t.Errorf("StockRepositoryMock.Reserve got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserve.ReserveMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

			if mm_want_ptrs.count != nil && !minimock.Equal(*mm_want_ptrs.count, mm_got.count) {
				mmReserve.t.Errorf("StockRepositoryMock.Reserve got unexpected parameter count, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserve.ReserveMock.defaultExpectation.expectationOrigins.originCount, *mm_want_ptrs.count, mm_got.count, minimock.Diff(*mm_want_ptrs.count, mm_got.count))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserve.t.Errorf("StockRepositoryMock.Reserve got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReserve.ReserveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserve.ReserveMock.defaultExpectation.results
		if mm_results == nil {
			mmReserve.t.Fatal("No results are set for the StockRepositoryMock.Reserve")
		}
		return (*mm_results).err
	}
	if mmReserve.funcReserve != nil {
		return mmReserve.funcReserve(ctx, sku, count)
	}
	mmReserve.t.Fatalf("Unexpected call to StockRepositoryMock.Reserve. %v %v %v", ctx, sku, count)
	return
}

// ReserveAfterCounter returns a count of finished StockRepositoryMock.Reserve invocations
func (mmReserve *StockRepositoryMock) ReserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserve.afterReserveCounter)
}

// ReserveBeforeCounter returns a count of StockRepositoryMock.Reserve invocations
func (mmReserve *StockRepositoryMock) ReserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserve.beforeReserveCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.Reserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserve *mStockRepositoryMockReserve) Calls() []*StockRepositoryMockReserveParams {
	mmReserve.mutex.RLock()

	argCopy := make([]*StockRepositoryMockReserveParams, len(mmReserve.callArgs))
	copy(argCopy, mmReserve.callArgs)

	mmReserve.mutex.RUnlock()

	return argCopy
}

// MinimockReserveDone returns true if the count of the Reserve invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockReserveDone() bool {
	if m.ReserveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveMock.invocationsDone()
}

// MinimockReserveInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockReserveInspect() {
	for _, e := range m.ReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.Reserve at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReserveCounter := mm_atomic.LoadUint64(&m.afterReserveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveMock.defaultExpectation != nil && afterReserveCounter < 1 {
		if m.ReserveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockRepositoryMock.Reserve at\n%s", m.ReserveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.Reserve at\n%s with params: %#v", m.ReserveMock.defaultExpectation.expectationOrigins.origin, *m.ReserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserve != nil && afterReserveCounter < 1 {
		m.t.Errorf("Expected call to StockRepositoryMock.Reserve at\n%s", m.funcReserveOrigin)
	}

	if !m.ReserveMock.invocationsDone() && afterReserveCounter > 0 {
		m.t.Errorf("Expected %d calls to StockRepositoryMock.Reserve at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveMock.expectedInvocations), m.ReserveMock.expectedInvocationsOrigin, afterReserveCounter)
	}
}

type mStockRepositoryMockReserveRemove struct {
	optional           bool
	mock               *StockRepositoryMock
	defaultExpectation *StockRepositoryMockReserveRemoveExpectation
	expectations       []*StockRepositoryMockReserveRemoveExpectation

	callArgs []*StockRepositoryMockReserveRemoveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockRepositoryMockReserveRemoveExpectation specifies expectation struct of the StockRepository.ReserveRemove
type StockRepositoryMockReserveRemoveExpectation struct {
	mock               *StockRepositoryMock
	params             *StockRepositoryMockReserveRemoveParams
	paramPtrs          *StockRepositoryMockReserveRemoveParamPtrs
	expectationOrigins StockRepositoryMockReserveRemoveExpectationOrigins
	results            *StockRepositoryMockReserveRemoveResults
	returnOrigin       string
	Counter            uint64
}

// StockRepositoryMockReserveRemoveParams contains parameters of the StockRepository.ReserveRemove
type StockRepositoryMockReserveRemoveParams struct {
	ctx   context.Context
	sku   uint32
	count uint16
}

// StockRepositoryMockReserveRemoveParamPtrs contains pointers to parameters of the StockRepository.ReserveRemove
type StockRepositoryMockReserveRemoveParamPtrs struct {
	ctx   *context.Context
	sku   *uint32
	count *uint16
}

// StockRepositoryMockReserveRemoveResults contains results of the StockRepository.ReserveRemove
type StockRepositoryMockReserveRemoveResults struct {
	err error
}

// StockRepositoryMockReserveRemoveOrigins contains origins of expectations of the StockRepository.ReserveRemove
type StockRepositoryMockReserveRemoveExpectationOrigins struct {
	origin      string
	originCtx   string
	originSku   string
	originCount string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Optional() *mStockRepositoryMockReserveRemove {
	mmReserveRemove.optional = true
	return mmReserveRemove
}

// Expect sets up expected params for StockRepository.ReserveRemove
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Expect(ctx context.Context, sku uint32, count uint16) *mStockRepositoryMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockRepositoryMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.paramPtrs != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by ExpectParams functions")
	}

	mmReserveRemove.defaultExpectation.params = &StockRepositoryMockReserveRemoveParams{ctx, sku, count}
	mmReserveRemove.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReserveRemove.expectations {
		if minimock.Equal(e.params, mmReserveRemove.defaultExpectation.params) {
			mmReserveRemove.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveRemove.defaultExpectation.params)
		}
	}

	return mmReserveRemove
}

// ExpectCtxParam1 sets up expected param ctx for StockRepository.ReserveRemove
func (mmReserveRemove *mStockRepositoryMockReserveRemove) ExpectCtxParam1(ctx context.Context) *mStockRepositoryMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockRepositoryMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.params != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Expect")
	}

	if mmReserveRemove.defaultExpectation.paramPtrs == nil {
		mmReserveRemove.defaultExpectation.paramPtrs = &StockRepositoryMockReserveRemoveParamPtrs{}
	}
	mmReserveRemove.defaultExpectation.paramPtrs.ctx = &ctx
	mmReserveRemove.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReserveRemove
}

// ExpectSkuParam2 sets up expected param sku for StockRepository.ReserveRemove
func (mmReserveRemove *mStockRepositoryMockReserveRemove) ExpectSkuParam2(sku uint32) *mStockRepositoryMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockRepositoryMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.params != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Expect")
	}

	if mmReserveRemove.defaultExpectation.paramPtrs == nil {
		mmReserveRemove.defaultExpectation.paramPtrs = &StockRepositoryMockReserveRemoveParamPtrs{}
	}
	mmReserveRemove.defaultExpectation.paramPtrs.sku = &sku
	mmReserveRemove.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmReserveRemove
}

// ExpectCountParam3 sets up expected param count for StockRepository.ReserveRemove
func (mmReserveRemove *mStockRepositoryMockReserveRemove) ExpectCountParam3(count uint16) *mStockRepositoryMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockRepositoryMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.params != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Expect")
	}

	if mmReserveRemove.defaultExpectation.paramPtrs == nil {
		mmReserveRemove.defaultExpectation.paramPtrs = &StockRepositoryMockReserveRemoveParamPtrs{}
	}
	mmReserveRemove.defaultExpectation.paramPtrs.count = &count
	mmReserveRemove.defaultExpectation.expectationOrigins.originCount = minimock.CallerInfo(1)

	return mmReserveRemove
}

// Inspect accepts an inspector function that has same arguments as the StockRepository.ReserveRemove
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Inspect(f func(ctx context.Context, sku uint32, count uint16)) *mStockRepositoryMockReserveRemove {
	if mmReserveRemove.mock.inspectFuncReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("Inspect function is already set for StockRepositoryMock.ReserveRemove")
	}

	mmReserveRemove.mock.inspectFuncReserveRemove = f

	return mmReserveRemove
}

// Return sets up results that will be returned by StockRepository.ReserveRemove
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Return(err error) *StockRepositoryMock {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockRepositoryMockReserveRemoveExpectation{mock: mmReserveRemove.mock}
	}
	mmReserveRemove.defaultExpectation.results = &StockRepositoryMockReserveRemoveResults{err}
	mmReserveRemove.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReserveRemove.mock
}

// Set uses given function f to mock the StockRepository.ReserveRemove method
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Set(f func(ctx context.Context, sku uint32, count uint16) (err error)) *StockRepositoryMock {
	if mmReserveRemove.defaultExpectation != nil {
		mmReserveRemove.mock.t.Fatalf("Default expectation is already set for the StockRepository.ReserveRemove method")
	}

	if len(mmReserveRemove.expectations) > 0 {
		mmReserveRemove.mock.t.Fatalf("Some expectations are already set for the StockRepository.ReserveRemove method")
	}

	mmReserveRemove.mock.funcReserveRemove = f
	mmReserveRemove.mock.funcReserveRemoveOrigin = minimock.CallerInfo(1)
	return mmReserveRemove.mock
}

// When sets expectation for the StockRepository.ReserveRemove which will trigger the result defined by the following
// Then helper
func (mmReserveRemove *mStockRepositoryMockReserveRemove) When(ctx context.Context, sku uint32, count uint16) *StockRepositoryMockReserveRemoveExpectation {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockRepositoryMock.ReserveRemove mock is already set by Set")
	}

	expectation := &StockRepositoryMockReserveRemoveExpectation{
		mock:               mmReserveRemove.mock,
		params:             &StockRepositoryMockReserveRemoveParams{ctx, sku, count},
		expectationOrigins: StockRepositoryMockReserveRemoveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReserveRemove.expectations = append(mmReserveRemove.expectations, expectation)
	return expectation
}

// Then sets up StockRepository.ReserveRemove return parameters for the expectation previously defined by the When method
func (e *StockRepositoryMockReserveRemoveExpectation) Then(err error) *StockRepositoryMock {
	e.results = &StockRepositoryMockReserveRemoveResults{err}
	return e.mock
}

// Times sets number of times StockRepository.ReserveRemove should be invoked
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Times(n uint64) *mStockRepositoryMockReserveRemove {
	if n == 0 {
		mmReserveRemove.mock.t.Fatalf("Times of StockRepositoryMock.ReserveRemove mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserveRemove.expectedInvocations, n)
	mmReserveRemove.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReserveRemove
}

func (mmReserveRemove *mStockRepositoryMockReserveRemove) invocationsDone() bool {
	if len(mmReserveRemove.expectations) == 0 && mmReserveRemove.defaultExpectation == nil && mmReserveRemove.mock.funcReserveRemove == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserveRemove.mock.afterReserveRemoveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserveRemove.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReserveRemove implements mm_service.StockRepository
func (mmReserveRemove *StockRepositoryMock) ReserveRemove(ctx context.Context, sku uint32, count uint16) (err error) {
	mm_atomic.AddUint64(&mmReserveRemove.beforeReserveRemoveCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveRemove.afterReserveRemoveCounter, 1)

	mmReserveRemove.t.Helper()

	if mmReserveRemove.inspectFuncReserveRemove != nil {
		mmReserveRemove.inspectFuncReserveRemove(ctx, sku, count)
	}

	mm_params := StockRepositoryMockReserveRemoveParams{ctx, sku, count}

	// Record call args
	mmReserveRemove.ReserveRemoveMock.mutex.Lock()
	mmReserveRemove.ReserveRemoveMock.callArgs = append(mmReserveRemove.ReserveRemoveMock.callArgs, &mm_params)
	mmReserveRemove.ReserveRemoveMock.mutex.Unlock()

	for _, e := range mmReserveRemove.ReserveRemoveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveRemove.ReserveRemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveRemove.ReserveRemoveMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveRemove.ReserveRemoveMock.defaultExpectation.params
		mm_want_ptrs := mmReserveRemove.ReserveRemoveMock.defaultExpectation.paramPtrs

		mm_got := StockRepositoryMockReserveRemoveParams{ctx, sku, count}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserveRemove.t.Errorf("StockRepositoryMock.ReserveRemove got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveRemove.ReserveRemoveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmReserveRemove.t.Errorf("StockRepositoryMock.ReserveRemove got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveRemove.ReserveRemoveMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

			if mm_want_ptrs.count != nil && !minimock.Equal(*mm_want_ptrs.count, mm_got.count) {
				mmReserveRemove.t.Errorf("StockRepositoryMock.ReserveRemove got unexpected parameter count, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveRemove.ReserveRemoveMock.defaultExpectation.expectationOrigins.originCount, *mm_want_ptrs.count, mm_got.count, minimock.Diff(*mm_want_ptrs.count, mm_got.count))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveRemove.t.Errorf("StockRepositoryMock.ReserveRemove got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReserveRemove.ReserveRemoveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveRemove.ReserveRemoveMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveRemove.t.Fatal("No results are set for the StockRepositoryMock.ReserveRemove")
		}
		return (*mm_results).err
	}
	if mmReserveRemove.funcReserveRemove != nil {
		return mmReserveRemove.funcReserveRemove(ctx, sku, count)
	}
	mmReserveRemove.t.Fatalf("Unexpected call to StockRepositoryMock.ReserveRemove. %v %v %v", ctx, sku, count)
	return
}

// ReserveRemoveAfterCounter returns a count of finished StockRepositoryMock.ReserveRemove invocations
func (mmReserveRemove *StockRepositoryMock) ReserveRemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveRemove.afterReserveRemoveCounter)
}

// ReserveRemoveBeforeCounter returns a count of StockRepositoryMock.ReserveRemove invocations
func (mmReserveRemove *StockRepositoryMock) ReserveRemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveRemove.beforeReserveRemoveCounter)
}

// Calls returns a list of arguments used in each call to StockRepositoryMock.ReserveRemove.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveRemove *mStockRepositoryMockReserveRemove) Calls() []*StockRepositoryMockReserveRemoveParams {
	mmReserveRemove.mutex.RLock()

	argCopy := make([]*StockRepositoryMockReserveRemoveParams, len(mmReserveRemove.callArgs))
	copy(argCopy, mmReserveRemove.callArgs)

	mmReserveRemove.mutex.RUnlock()

	return argCopy
}

// MinimockReserveRemoveDone returns true if the count of the ReserveRemove invocations corresponds
// the number of defined expectations
func (m *StockRepositoryMock) MinimockReserveRemoveDone() bool {
	if m.ReserveRemoveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveRemoveMock.invocationsDone()
}

// MinimockReserveRemoveInspect logs each unmet expectation
func (m *StockRepositoryMock) MinimockReserveRemoveInspect() {
	for _, e := range m.ReserveRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockRepositoryMock.ReserveRemove at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReserveRemoveCounter := mm_atomic.LoadUint64(&m.afterReserveRemoveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveRemoveMock.defaultExpectation != nil && afterReserveRemoveCounter < 1 {
		if m.ReserveRemoveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockRepositoryMock.ReserveRemove at\n%s", m.ReserveRemoveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockRepositoryMock.ReserveRemove at\n%s with params: %#v", m.ReserveRemoveMock.defaultExpectation.expectationOrigins.origin, *m.ReserveRemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveRemove != nil && afterReserveRemoveCounter < 1 {
		m.t.Errorf("Expected call to StockRepositoryMock.ReserveRemove at\n%s", m.funcReserveRemoveOrigin)
	}

	if !m.ReserveRemoveMock.invocationsDone() && afterReserveRemoveCounter > 0 {
		m.t.Errorf("Expected %d calls to StockRepositoryMock.ReserveRemove at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveRemoveMock.expectedInvocations), m.ReserveRemoveMock.expectedInvocationsOrigin, afterReserveRemoveCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StockRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetBySKUInspect()

			m.MinimockReleaseInspect()

			m.MinimockReserveInspect()

			m.MinimockReserveRemoveInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StockRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StockRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetBySKUDone() &&
		m.MinimockReleaseDone() &&
		m.MinimockReserveDone() &&
		m.MinimockReserveRemoveDone()
}
